// Generated by CoffeeScript 1.12.2
(function() {
  var Emitter, Property, XPath, clone, co, context, debug, delegate,
    hasProp = {}.hasOwnProperty;

  if (process.env.DEBUG != null) {
    debug = require('debug')('yang:property');
  }

  co = require('co');

  delegate = require('delegates');

  clone = require('clone');

  Emitter = require('events').EventEmitter;

  context = require('./context');

  XPath = require('./xpath');

  Property = (function() {
    Property.property = function(prop, desc) {
      return Object.defineProperty(this.prototype, prop, desc);
    };

    function Property(name1, schema) {
      var base, ref;
      this.name = name1;
      this.schema = schema != null ? schema : {};
      if (!(this instanceof Property)) {
        return (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(Property, arguments, function(){});
      }
      this.state = {
        value: null,
        container: null,
        configurable: true,
        enumerable: this.binding != null,
        mutable: ((ref = this.schema.config) != null ? ref.valueOf() : void 0) !== false
      };
      Object.setPrototypeOf(this.state, Emitter.prototype);
      if ((base = this.schema).kind == null) {
        base.kind = 'anydata';
      }
      this.set = this.set.bind(this);
      this.get = this.get.bind(this);
      Object.preventExtensions(this);
    }

    delegate(Property.prototype, 'state').method('once').method('on').access('container').getter('configurable').getter('enumerable').getter('mutable');

    delegate(Property.prototype, 'schema').getter('kind').getter('type').getter('binding');

    Property.property('content', {
      get: function() {
        return this.state.value;
      },
      set: function(value) {
        return this.set(value, {
          force: true
        });
      }
    });

    Property.property('context', {
      get: function() {
        var ctx;
        ctx = Object.create(context);
        ctx.state = {};
        ctx.property = this;
        Object.preventExtensions(ctx);
        return ctx;
      }
    });

    Property.property('parent', {
      get: function() {
        var ref;
        return (ref = this.container) != null ? ref.__ : void 0;
      }
    });

    Property.property('root', {
      get: function() {
        var root;
        if (this.kind === 'module') {
          return this;
        }
        root = (function() {
          switch (false) {
            case this.parent !== this:
              return this;
            case !(this.parent instanceof Property):
              return this.parent.root;
            default:
              return this;
          }
        }).call(this);
        if (this.state.root !== root) {
          this.state.path = void 0;
        }
        return this.state.root = root;
      }
    });

    Property.property('props', {
      get: function() {
        var k, prop, ref, ref1, results;
        ref1 = (ref = this.content) != null ? ref.__props__ : void 0;
        results = [];
        for (k in ref1) {
          prop = ref1[k];
          results.push(prop);
        }
        return results;
      }
    });

    Property.property('key', {
      get: function() {
        var idx, item, ref, ref1;
        if (this.schema !== ((ref = this.parent) != null ? ref.schema : void 0)) {
          return;
        }
        switch (false) {
          case this.content instanceof Object:
            return this.name + 1;
          case !this.content.hasOwnProperty('@key'):
            return this.content['@key'];
          case !Array.isArray(this.container):
            ref1 = this.container;
            for (idx in ref1) {
              item = ref1[idx];
              if (!(item === this.content)) {
                continue;
              }
              if (!(Number.isNaN(Number(idx)))) {
                idx = Number(idx);
              }
              return idx + 1;
            }
            return void 0;
        }
      }
    });

    Property.property('path', {
      get: function() {
        var entity, key;
        if (this === this.root) {
          entity = (function() {
            switch (false) {
              case this.kind !== 'module':
                return '/';
              default:
                return '.';
            }
          }).call(this);
          return XPath.parse(entity, this.schema);
        }
        key = this.key;
        if ((this.state.path != null) && (key == null)) {
          return this.state.path;
        }
        this.debug("[path] " + this.kind + "(" + this.name + ") has " + key + " " + (typeof key));
        entity = (function() {
          switch (typeof key) {
            case 'number':
              return ".[" + key + "]";
            case 'string':
              return ".[key('" + key + "')]";
            default:
              switch (false) {
                case this.kind !== 'list':
                  return this.schema.datakey;
                default:
                  return this.name;
              }
          }
        }).call(this);
        this.debug("[path] " + this.parent.name + " + " + entity);
        return this.state.path = this.parent.path.clone().append(entity);
      }
    });

    Property.prototype.clone = function() {
      var copy, k, ref, v;
      this.debug("[clone] cloning with " + this.props.length + " properties");
      copy = new this.constructor(this.name, this.schema);
      ref = this.state;
      for (k in ref) {
        v = ref[k];
        copy.state[k] = v;
      }
      return copy;
    };

    Property.prototype.emit = function(event) {
      var ref, ref1;
      (ref = this.state).emit.apply(ref, arguments);
      if (this !== this.root) {
        this.debug("[emit] '" + event + "' to '" + this.root.name + "'");
        return (ref1 = this.root).emit.apply(ref1, arguments);
      }
    };

    Property.prototype.join = function(obj, opts) {
      var detached, exists;
      if (opts == null) {
        opts = {
          replace: false,
          suppress: false,
          force: false
        };
      }
      if (!(obj instanceof Object)) {
        return obj;
      }
      if (this.container == null) {
        detached = true;
      }
      this.container = obj;
      if (Array.isArray(obj) && Array.isArray(this.content)) {
        this.debug(this.content);
        throw this.error("cannot join array property into list container");
      }
      if (this.kind === 'list' && !Array.isArray(obj) && (this.content != null) && !Array.isArray(this.content)) {
        throw this.error("cannot join non-list array property into containing object");
      }
      exists = obj[this.name];
      if (detached && opts.replace !== true) {
        opts.suppress = true;
        this.set(exists, opts);
      }
      Object.defineProperty(obj, this.name, this);
      if (!obj.hasOwnProperty('__props__')) {
        Object.defineProperty(obj, '__props__', {
          value: {}
        });
      }
      obj.__props__[this.name] = this;
      this.debug("[join] attached into " + obj.constructor.name + " container");
      return obj;
    };

    Property.prototype.get = function(pattern, prop) {
      var e, match, ref;
      if (prop == null) {
        prop = false;
      }
      switch (false) {
        case !((pattern != null) && prop):
          return this["in"](pattern);
        case pattern == null:
          match = this.find(pattern);
          switch (false) {
            case match.length !== 1:
              return match[0].content;
            case !(match.length > 1):
              return match.map(function(x) {
                return x.content;
              });
            default:
              return void 0;
          }
          break;
        case (ref = this.kind) !== 'rpc' && ref !== 'action':
          switch (false) {
            case this.binding == null:
              return this["do"].bind(this);
            default:
              return this.content;
          }
          break;
        default:
          try {
            if ((this.binding != null) && !(this.kind === 'list' && (this.key != null))) {
              this.binding.call(this.context);
            }
          } catch (error) {
            e = error;
            throw this.error("issue executing registered function binding during get()", e);
          }
          return this.content;
      }
    };

    Property.prototype.set = function(value, opts) {
      var desc, e, k, ref, ref1;
      if (opts == null) {
        opts = {
          force: false,
          suppress: false
        };
      }
      this.debug("[set] enter with:");
      this.debug(value);
      if (value === this.content && !opts.force) {
        return this;
      }
      if (!(this.mutable || (value == null) || opts.force)) {
        throw this.error("cannot set data on read-only element");
      }
      try {
        if (!(value instanceof Function)) {
          if (value.__ instanceof Property && value.__ !== this) {
            this.debug("[set] cloning existing property for assignment");
            value = clone(value);
          }
          if (!Object.isExtensible(value)) {
            value = Object.create(value);
          }
        }
        Object.defineProperty(value, '__', {
          configurable: true,
          value: this
        });
      } catch (error) {}
      value = (function() {
        switch (false) {
          case this.schema.apply == null:
            return this.schema.apply(value, this.context["with"](opts));
          default:
            return value;
        }
      }).call(this);
      if (value instanceof Error) {
        return this;
      }
      try {
        Object.defineProperties(value, {
          '__': {
            value: this
          },
          '$': {
            value: this.get.bind(this)
          }
        });
        if (this.schema.nodes.length && this.kind !== 'module') {
          for (k in value) {
            if (!hasProp.call(value, k)) continue;
            desc = Object.getOwnPropertyDescriptor(value, k);
            if (desc.writable === true && (this.schema.locate(k) == null)) {
              this.debug("[set] hiding non-schema defined property: " + k);
              Object.defineProperty(value, k, {
                enumerable: false
              });
            }
          }
        }
      } catch (error) {}
      this.state.prev = this.state.value;
      this.state.enumerable = (value != null) || (this.binding != null);
      if (((ref = this.binding) != null ? ref.length : void 0) === 1 && !opts.force && ((ref1 = this.kind) !== 'action' && ref1 !== 'rpc')) {
        try {
          this.binding.call(this.context, value);
        } catch (error) {
          e = error;
          throw this.error("issue executing registered function binding during set()", e);
        }
      } else {
        this.state.value = value;
      }
      try {
        Object.defineProperty(this.container, this.name, {
          configurable: true,
          enumerable: this.state.enumerable
        });
      } catch (error) {}
      if (this === this.root || !opts.suppress) {
        this.emit('update', this);
      }
      this.debug("[set] completed");
      return this;
    };

    Property.prototype.merge = function(value, opts) {
      var attr, combine, conflicts, copy, exists, i, k, len, length, newitems, ref, v;
      if (opts == null) {
        opts = {
          replace: true,
          suppress: false
        };
      }
      if (opts.replace == null) {
        opts.replace = true;
      }
      if (!(this.content instanceof Object)) {
        opts.replace = false;
        return this.set(value, opts);
      }
      if ((value != null) && value.hasOwnProperty(this.name)) {
        value = value[this.name];
      }
      if (!(value instanceof Object)) {
        return this;
      }
      if (Array.isArray(this.content)) {
        length = this.content.length;
        this.debug("[merge] merging into existing Array(" + length + ") for " + this.name);
        this.debug(value);
        if (!Array.isArray(value)) {
          value = [value];
        }
        copy = this.clone();
        copy.set(value, {
          force: opts.force,
          suppress: true
        });
        this.debug("[merge] combining and applying schema");
        if ((this.schema.key != null) && opts.replace) {
          exists = {};
          this.content.forEach(function(item) {
            var key;
            key = item['@key'];
            return exists[key] = item;
          });
          this.debug("[merge] reducing existing keys");
          conflicts = 0;
          newitems = copy.content.reduce((function(a, item) {
            var key;
            key = item['@key'];
            item.__.name -= conflicts;
            if (key in exists) {
              conflicts++;
              exists[key].__.merge(item);
            } else {
              a.push(item);
            }
            return a;
          }), []);
          combine = this.content.concat(newitems);
        } else {
          newitems = copy.content;
          combine = this.content.concat(newitems);
        }
        ref = this.schema.attrs;
        for (i = 0, len = ref.length; i < len; i++) {
          attr = ref[i];
          attr.apply(combine);
        }
        newitems.forEach((function(_this) {
          return function(item) {
            item.__.name += length;
            return item.__.join(_this.content, opts);
          };
        })(this));
        if (!opts.suppress) {
          this.emit('update', copy);
        }
        return copy;
      } else {
        this.debug("[merge] merging into existing Object(" + (Object.keys(this.content).length) + ") for " + this.name);
        for (k in value) {
          if (!hasProp.call(value, k)) continue;
          v = value[k];
          if (this.content.hasOwnProperty(k)) {
            this.content[k] = v;
          }
        }
        return this;
      }
    };

    Property.prototype.create = function(value) {
      var res;
      if ((this.content == null) && this.kind === 'list' && !Array.isArray(value)) {
        value = [value];
      }
      res = this.merge(value, {
        replace: false
      });
      this.emit('create', res);
      return res;
    };

    Property.prototype.remove = function() {
      if (this.container == null) {
        return this;
      }
      if (this.key != null) {
        this.container.splice(this.name, 1);
      } else {
        this.state.enumerable = false;
        if (this.kind !== 'list') {
          this.state.value = void 0;
        }
        Object.defineProperty(this.container, this.name, {
          enumerable: false
        });
      }
      if (this.parent != null) {
        this.emit('update', this.parent);
      }
      this.emit('delete', this);
      return this;
    };

    Property.prototype.find = function(pattern, opts) {
      var ref, ref1;
      if (pattern == null) {
        pattern = '.';
      }
      if (opts == null) {
        opts = {};
      }
      this.debug("[find] " + pattern);
      if (!(pattern instanceof XPath)) {
        if (/^\.\.\//.test(pattern) && (this.parent != null)) {
          return this.parent.find(pattern.replace(/^\.\.\//, ''), opts);
        }
        if (/^\//.test(pattern) && this !== this.root) {
          return this.root.find(pattern, opts);
        }
        pattern = XPath.parse(pattern, this.schema);
      }
      this.debug("[find] using " + pattern);
      if (opts.root || (this.container == null) || ((ref = pattern.tag) !== '/' && ref !== '..')) {
        this.debug("[find] apply " + pattern);
        this.debug(this.content);
        return (ref1 = pattern.apply(this.content).props) != null ? ref1 : [];
      } else {
        switch (false) {
          case !(pattern.tag === '/' && (this.parent != null)):
            return this.parent.find(pattern, opts);
          case !(pattern.tag === '..' && (this.parent != null)):
            return this.parent.find(pattern.xpath, opts);
          default:
            return [];
        }
      }
    };

    Property.prototype["in"] = function(pattern) {
      var props;
      try {
        props = this.find(pattern);
      } catch (error) {}
      if (!((props != null) && props.length)) {
        return;
      }
      switch (false) {
        case !(props.length > 1):
          return props;
        default:
          return props[0];
      }
    };

    Property.prototype.invoke = function() {
      console.warn("DEPRECATION: please use .do() instead");
      return this["do"].apply(this, arguments);
    };

    Property.prototype["do"] = function() {
      var ctx, e, ref, ref1;
      if (!(this.content instanceof Function)) {
        return Promise.reject(this.error("cannot perform action on a property without function"));
      }
      try {
        this.debug("[do] executing method: " + this.name);
        ctx = this.context["with"]({
          '__': this
        });
        if ((ref = this.schema.input) != null) {
          ref["eval"](ctx.state);
        }
        if ((ref1 = this.schema.output) != null) {
          ref1["eval"](ctx.state);
        }
        ctx.input = arguments;
        if (this.binding != null) {
          this.debug("[do] calling bound function");
          this.debug(this.binding.toString());
          this.binding.apply(ctx, arguments);
        } else {
          this.debug("[do] calling assigned function");
          this.debug(this.content.toString());
          ctx.output = this.content.apply(ctx, arguments);
        }
        return co((function(_this) {
          return function*() {
            _this.debug("[do] evaluating output schema");
            ctx.output = (yield Promise.resolve(ctx.output));
            _this.debug("[do] finish setting output");
            return ctx.output;
          };
        })(this));
      } catch (error) {
        e = error;
        this.debug(e);
        return Promise.reject(e);
      }
    };

    Property.prototype.error = function(msg, ctx) {
      var at, res;
      if (ctx == null) {
        ctx = this;
      }
      at = "" + this.path;
      if (at === '/') {
        at += this.name;
      }
      res = new Error("[" + at + "] " + msg);
      res.name = 'PropertyError';
      res.context = ctx;
      return res;
    };

    Property.prototype.debug = function(msg) {
      var node, prefix;
      if (debug != null) {
        switch (typeof msg) {
          case 'object':
            return debug(msg);
          default:
            node = this;
            prefix = [this.name];
            while ((node = node.parent)) {
              prefix.unshift(node.name);
            }
            return debug("[" + (prefix.join('/')) + "] " + msg);
        }
      }
    };

    Property.prototype.inspect = function() {
      var ref;
      return {
        name: (ref = this.schema.tag) != null ? ref : this.name,
        kind: this.schema.kind,
        key: this.key,
        xpath: this.path.toString(),
        schema: this.schema.toJSON({
          tag: false,
          extended: true
        }),
        active: this.enumerable,
        readonly: !this.mutable
      };
    };

    Property.prototype.toJSON = function(tag) {
      var copy, name, obj1, value;
      if (tag == null) {
        tag = true;
      }
      copy = function(src) {
        var k, res, v;
        if (!((src != null) && typeof src !== 'function')) {
          return;
        }
        if (typeof src === 'object') {
          try {
            res = new src.constructor;
          } catch (error) {
            res = {};
          }
          for (k in src) {
            if (!hasProp.call(src, k)) continue;
            v = src[k];
            if (typeof v !== 'function') {
              res[k] = copy(v);
            }
          }
          return res;
        }
        return src.constructor.call(src, src);
      };
      value = copy(this.get());
      if (this.kind === 'list') {
        if (value == null) {
          value = [];
        }
      }
      if (tag) {
        name = (function() {
          switch (false) {
            case this.kind !== 'list':
              return this.schema.datakey;
            default:
              return this.name;
          }
        }).call(this);
        return (
          obj1 = {},
          obj1["" + name] = value,
          obj1
        );
      } else {
        return value;
      }
    };

    return Property;

  })();

  module.exports = Property;

}).call(this);
