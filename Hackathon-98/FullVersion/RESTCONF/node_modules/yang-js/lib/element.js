// Generated by CoffeeScript 1.12.2
(function() {
  var Element, Emitter, debug, delegate,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  debug = require('debug')('yang:element');

  delegate = require('delegates');

  Emitter = require('events').EventEmitter;

  Emitter.defaultMaxListeners = 100;

  Element = (function() {
    Element.property = function(prop, desc) {
      return Object.defineProperty(this.prototype, prop, desc);
    };

    Element.use = function() {
      var ref, res;
      res = (ref = []).concat.apply(ref, arguments).filter(function(x) {
        return x != null;
      }).map((function(_this) {
        return function(elem) {
          var e, exists;
          exists = Element.prototype.match.call(_this, elem.kind, elem.tag);
          if (exists != null) {
            console.warn(_this.error("use: already loaded '" + elem.kind + ":" + elem.tag + "'"));
            return exists;
          }
          try {
            return Element.prototype.merge.call(_this, elem);
          } catch (error) {
            e = error;
            throw _this.error("use: unable to merge '" + elem.kind + ":" + elem.tag + "'", e);
          }
        };
      })(this));
      switch (false) {
        case !(res.length > 1):
          return res;
        case res.length !== 1:
          return res[0];
        default:
          return void 0;
      }
    };

    Element.debug = function(msg) {
      switch (typeof msg) {
        case 'object':
          return typeof debug === "function" ? debug(msg) : void 0;
        default:
          return typeof debug === "function" ? debug("[" + this.trail + "] " + msg) : void 0;
      }
    };

    Element.error = function(msg, ctx) {
      var res;
      if (ctx == null) {
        ctx = this;
      }
      res = new Error(msg);
      res.name = 'ElementError';
      res.context = ctx;
      return res;
    };

    function Element(kind1, tag1, source) {
      this.kind = kind1;
      this.tag = tag1;
      if (source == null) {
        source = {};
      }
      if (this.kind == null) {
        throw this.error("must supply 'kind' to create a new Element");
      }
      if (!(source instanceof Object)) {
        throw this.error("must supply 'source' as an object");
      }
      Object.defineProperties(this, {
        parent: {
          value: null,
          writable: true
        },
        origin: {
          value: null,
          writable: true
        },
        source: {
          value: source,
          writable: true
        },
        state: {
          value: {},
          writable: true
        },
        emitter: {
          value: new Emitter
        }
      });
    }

    delegate(Element.prototype, 'emitter').method('emit').method('once').method('on');

    delegate(Element.prototype, 'source').getter('scope').getter('construct');

    Element.property('trail', {
      get: function() {
        var mark, ref;
        mark = this.kind;
        if ((this.tag != null) && ((ref = this.source.argument) !== 'value' && ref !== 'text')) {
          mark += "(" + this.tag + ")";
        }
        if (!(this.parent instanceof Element)) {
          return mark;
        }
        return this.parent.trail + "/" + mark;
      }
    });

    Element.property('root', {
      get: function() {
        switch (false) {
          case !(this.parent instanceof Element):
            return this.parent.root;
          case !(this.origin instanceof Element):
            return this.origin.root;
          default:
            return this;
        }
      }
    });

    Element.property('node', {
      get: function() {
        return this.construct instanceof Function;
      }
    });

    Element.property('elements', {
      get: function() {
        var k, v;
        return ((function() {
          var ref, results;
          ref = this;
          results = [];
          for (k in ref) {
            v = ref[k];
            if (k !== 'parent' && k !== 'origin' && k !== 'tag') {
              results.push(v);
            }
          }
          return results;
        }).call(this)).reduce((function(a, b) {
          switch (false) {
            case !(b instanceof Element):
              return a.concat(b);
            case !(b instanceof Array):
              return a.concat(b.filter(function(x) {
                return x instanceof Element;
              }));
            default:
              return a;
          }
        }), []);
      }
    });

    Element.property('nodes', {
      get: function() {
        return this.elements.filter(function(x) {
          return x.node === true;
        });
      }
    });

    Element.property('attrs', {
      get: function() {
        return this.elements.filter(function(x) {
          return x.node === false;
        });
      }
    });

    Element.property('*', {
      get: function() {
        return this.nodes;
      }
    });

    Element.property('..', {
      get: function() {
        return this.parent;
      }
    });

    Element.prototype.clone = function() {
      var copy, ref;
      this.debug("cloning " + this.kind + ":" + this.tag + " with " + this.elements.length + " elements");
      copy = (new this.constructor(this.kind, this.tag, this.source))["extends"](this.elements.map((function(_this) {
        return function(x) {
          var c;
          c = x.clone();
          if (x.parent !== _this) {
            c.parent = x.parent;
          }
          return c;
        };
      })(this)));
      copy.state = this.state;
      copy.origin = (ref = this.origin) != null ? ref : this;
      return copy;
    };

    Element.prototype["extends"] = function() {
      var elems, ref;
      elems = ((ref = []).concat.apply(ref, arguments)).filter(function(x) {
        return (x != null) && !!x;
      });
      if (!(elems.length > 0)) {
        return this;
      }
      elems.forEach((function(_this) {
        return function(expr) {
          return _this.merge(expr);
        };
      })(this));
      this.emit.apply(this, ['change'].concat(slice.call(elems)));
      return this;
    };

    Element.prototype.merge = function(elem, opts) {
      var _merge, exists;
      if (opts == null) {
        opts = {};
      }
      if (!(elem instanceof Element)) {
        throw this.error("cannot merge invalid element into Element", elem);
      }
      if (elem.parent == null) {
        elem.parent = this;
      }
      _merge = function(item) {
        var i, j, len, ref, ref1, ref2, x;
        if (opts.append === true || (ref = item.tag, indexOf.call((ref1 = this.tags) != null ? ref1 : [], ref) < 0)) {
          this.push(item);
          return true;
        } else if (opts.replace === true) {
          ref2 = this;
          for (i = j = 0, len = ref2.length; j < len; i = ++j) {
            x = ref2[i];
            if (!(x.tag === item.tag)) {
              continue;
            }
            this.splice(i, 1, item);
            break;
          }
          return true;
        } else {
          return false;
        }
      };
      if (this.scope == null) {
        if (!this.hasOwnProperty(elem.kind)) {
          this[elem.kind] = elem;
          return elem;
        }
        if (!Array.isArray(this[elem.kind])) {
          exists = this[elem.kind];
          this[elem.kind] = [exists];
          Object.defineProperty(this[elem.kind], 'tags', {
            get: (function() {
              return this.map(function(x) {
                return x.tag;
              });
            }).bind(this[elem.kind])
          });
        }
        if (!_merge.call(this[elem.kind], elem)) {
          throw this.error("constraint violation for '" + elem.kind + " " + elem.tag + "' - cannot define more than once");
        }
        return elem;
      }
      if (!(elem.kind in this.scope)) {
        if (elem.scope != null) {
          this.debug(this.scope);
          throw this.error("scope violation - invalid '" + elem.kind + "' extension found");
        } else {
          this.scope[elem.kind] = '*';
        }
      }
      switch (this.scope[elem.kind]) {
        case '0..n':
        case '1..n':
        case '*':
          if (!this.hasOwnProperty(elem.kind)) {
            this[elem.kind] = [];
            Object.defineProperty(this[elem.kind], 'tags', {
              get: (function() {
                return this.map(function(x) {
                  return x.tag;
                });
              }).bind(this[elem.kind])
            });
          }
          if (!_merge.call(this[elem.kind], elem)) {
            throw this.error("constraint violation for '" + elem.kind + " " + elem.tag + "' - already defined");
          }
          break;
        case '0..1':
        case '1':
          if (!this.hasOwnProperty(elem.kind)) {
            this[elem.kind] = elem;
          } else if (opts.replace === true) {
            this.debug("replacing pre-existing " + elem.kind);
            this[elem.kind] = elem;
          } else {
            throw this.error("constraint violation for '" + elem.kind + "' - cannot define more than once");
          }
          break;
        default:
          throw this.error("unrecognized scope constraint defined for '" + elem.kind + "' with " + this.scope[elem.kind]);
      }
      return elem;
    };

    Element.prototype.update = function(elem) {
      var exists, j, len, ref, target;
      if (!(elem instanceof Element)) {
        throw this.error("cannot update a non-Element into an Element", elem);
      }
      exists = Element.prototype.match.call(this, elem.kind, elem.tag);
      if (exists == null) {
        return this.merge(elem);
      }
      ref = elem.elements;
      for (j = 0, len = ref.length; j < len; j++) {
        target = ref[j];
        exists.update(target);
      }
      return exists;
    };

    Element.prototype.lookup = function(kind, tag) {
      var res;
      res = (function() {
        switch (false) {
          case this instanceof Object:
            return void 0;
          case !(this instanceof Element):
            return this.match(kind, tag);
          default:
            return Element.prototype.match.call(this, kind, tag);
        }
      }).call(this);
      if (res == null) {
        res = (function() {
          switch (false) {
            case this.origin == null:
              return Element.prototype.lookup.apply(this.origin, arguments);
            case this.parent == null:
              return Element.prototype.lookup.apply(this.parent, arguments);
            default:
              return Element.prototype.match.call(this.constructor, kind, tag);
          }
        }).apply(this, arguments);
      }
      return res;
    };

    Element.prototype.locate = function(ypath) {
      var key, match, ref, rest;
      if (ypath == null) {
        return;
      }
      if (typeof ypath === 'string') {
        this.debug("locate: " + ypath);
        ypath = ypath.replace(/\s/g, '');
        if ((/^\//.test(ypath)) && this !== this.root) {
          return this.root.locate(ypath);
        }
        ref = ypath.split('/').filter(function(e) {
          return !!e;
        }), key = ref[0], rest = 2 <= ref.length ? slice.call(ref, 1) : [];
      } else {
        this.debug("locate: " + (ypath.join('/')));
        key = ypath[0], rest = 2 <= ypath.length ? slice.call(ypath, 1) : [];
      }
      if (key == null) {
        return this;
      }
      match = (function() {
        switch (false) {
          case key !== '..':
            return this.match(key);
          default:
            return this.match('*', key);
        }
      }).call(this);
      switch (false) {
        case rest.length !== 0:
          return match;
        default:
          return match != null ? match.locate(rest) : void 0;
      }
    };

    Element.prototype.match = function(kind, tag) {
      var elem, j, key, len, match;
      if (!((kind != null) && (this[kind] != null))) {
        return;
      }
      if (tag == null) {
        return this[kind];
      }
      match = this[kind];
      if (!(match instanceof Array)) {
        match = [match];
      }
      if (tag === '*') {
        return match;
      }
      for (j = 0, len = match.length; j < len; j++) {
        elem = match[j];
        if (!(elem instanceof Element)) {
          continue;
        }
        key = elem.tag != null ? elem.tag : elem.kind;
        if (tag === key) {
          return elem;
        }
      }
      return void 0;
    };

    Element.prototype.error = Element.error;

    Element.prototype.debug = Element.debug;

    Element.prototype.toJSON = function(opts) {
      var obj, sub;
      if (opts == null) {
        opts = {
          tag: true,
          extended: false
        };
      }
      sub = this.elements.filter((function(_this) {
        return function(x) {
          return opts.extended || x.parent === _this;
        };
      })(this)).reduce((function(a, b) {
        var k, kk, ref, v, vv;
        ref = b.toJSON();
        for (k in ref) {
          v = ref[k];
          if (a[k] instanceof Object) {
            if (v instanceof Object) {
              for (kk in v) {
                vv = v[kk];
                a[k][kk] = vv;
              }
            }
          } else {
            a[k] = v;
          }
        }
        return a;
      }), {});
      if (opts.tag) {
        return (
          obj = {},
          obj["" + this.kind] = (function() {
            var obj1;
            switch (false) {
              case !(Object.keys(sub).length > 0):
                if (this.tag != null) {
                  return (
                    obj1 = {},
                    obj1["" + this.tag] = sub,
                    obj1
                  );
                } else {
                  return sub;
                }
                break;
              case !(this.tag instanceof Object):
                return "" + this.tag;
              default:
                return this.tag;
            }
          }).call(this),
          obj
        );
      } else {
        return sub;
      }
    };

    return Element;

  })();

  module.exports = Element;

}).call(this);
