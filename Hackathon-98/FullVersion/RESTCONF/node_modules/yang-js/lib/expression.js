// Generated by CoffeeScript 1.12.2
(function() {
  var Element, Expression, debug, delegate,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  if (process.env.DEBUG != null) {
    debug = require('debug')('yang:expression');
  }

  delegate = require('delegates');

  Element = require('./element');

  Expression = (function(superClass) {
    extend(Expression, superClass);

    delegate(Expression.prototype, 'source').getter('resolve').getter('transform').getter('construct').getter('predicate').getter('compose');

    Expression.property('exprs', {
      get: function() {
        return this.elements.filter(function(x) {
          return x instanceof Expression;
        });
      }
    });

    function Expression() {
      var BoundExpression, self;
      Expression.__super__.constructor.apply(this, arguments);
      this.argument = this.source.argument;
      BoundExpression = (function() {
        return self["eval"].apply(self, arguments);
      });
      self = Object.setPrototypeOf(BoundExpression, this);
      self.id = this.kind + (this.tag != null ? "(" + this.tag + ")" : '');
      delete self.length;
      return self;
    }

    Expression.prototype.clone = function() {
      var copy;
      copy = Expression.__super__.clone.apply(this, arguments);
      copy.resolved = this.resolved;
      if (this.binding != null) {
        copy.binding = this.binding;
      }
      if (this.convert != null) {
        copy.convert = this.convert;
      }
      if (this.node) {
        this.once('bind', function(func) {
          if (copy.binding == null) {
            copy.binding = func;
          }
          return copy.emit('bind', func);
        });
      }
      return copy;
    };

    Expression.prototype.compile = function() {
      var ref;
      if (typeof debug === "function") {
        debug("[" + this.trail + "] compile enter... (" + this.resolved + ")");
      }
      this.emit('compile:before', arguments);
      if (!this.resolved) {
        if ((ref = this.resolve) != null) {
          ref.apply(this, arguments);
        }
      }
      if ((this.tag != null) && (this.argument == null)) {
        throw this.error("cannot contain argument '" + this.tag + "' for expression '" + this.kind + "'");
      }
      if ((this.argument != null) && (this.tag == null)) {
        throw this.error("must contain argument '" + this.argument + "' for expression '" + this.kind + "'");
      }
      if (this.exprs.length) {
        if (typeof debug === "function") {
          debug("[" + this.trail + "] has sub-expressions: " + (this.exprs.map(function(x) {
            return x.kind;
          })));
        }
      }
      this.exprs.forEach(function(x) {
        return x.compile();
      });
      this.resolved = true;
      this.emit('compile:after');
      if (typeof debug === "function") {
        debug("[" + this.trail + "] compile: ok");
      }
      return this;
    };

    Expression.prototype.bind = function() {
      var binding, data, e, i, key, obj;
      key = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), data = arguments[i++];
      if (!(data instanceof Object)) {
        return this;
      }
      if (key.length) {
        return this.bind((
          obj = {},
          obj["" + key[0]] = data,
          obj
        ));
      }
      if (data instanceof Function) {
        if (typeof debug === "function") {
          debug("bind: registering function at " + this.trail);
        }
        this.binding = data;
        this.emit('bind', data);
        return this;
      }
      for (key in data) {
        binding = data[key];
        try {
          this.locate(key).bind(binding);
        } catch (error) {
          e = error;
          if (e.name === 'ExpressionError') {
            throw e;
          }
          throw this.error("failed to bind to '" + key + "' (schema-path not found)", e);
        }
      }
      return this;
    };

    Expression.prototype.apply = function(data, ctx) {
      var e, expr, i, len, ref, ref1;
      if (ctx == null) {
        ctx = {};
      }
      if (!this.resolved) {
        this.compile();
      }
      this.emit('apply:before', data);
      if (typeof debug === "function") {
        debug("[" + this.trail + "] applying data to schema expression:");
      }
      if (typeof debug === "function") {
        debug(this);
      }
      if (this.transform != null) {
        data = this.transform.call(this, data, ctx);
      } else {
        ref = this.exprs;
        for (i = 0, len = ref.length; i < len; i++) {
          expr = ref[i];
          if (data != null) {
            data = expr["eval"](data, ctx);
          }
        }
      }
      try {
        if ((ref1 = this.predicate) != null) {
          ref1.call(this, data);
        }
      } catch (error) {
        e = error;
        if (typeof debug === "function") {
          debug(data);
        }
        throw this.error("predicate validation error: " + e, data);
      }
      this.emit('apply:after', data);
      return data;
    };

    Expression.prototype["eval"] = function(data, ctx) {
      if (ctx == null) {
        ctx = {};
      }
      if (!this.resolved) {
        this.compile();
      }
      if (typeof debug === "function") {
        debug("[" + this.trail + "] eval");
      }
      if (typeof debug === "function") {
        debug(this);
      }
      if (this.node === true) {
        return this.construct.call(this, data, ctx);
      } else {
        return this.apply(data, ctx);
      }
    };

    Expression.prototype.update = function(elem) {
      var res;
      res = Expression.__super__.update.apply(this, arguments);
      res.binding = elem.binding;
      return res;
    };

    Expression.prototype.error = function() {
      var res;
      res = Expression.__super__.error.apply(this, arguments);
      res.name = 'ExpressionError';
      return res;
    };

    return Expression;

  })(Element);

  module.exports = Expression;

}).call(this);
