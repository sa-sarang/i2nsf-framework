// Generated by CoffeeScript 1.10.0
(function() {
  var P, YangStatement, argument, blockComment, comment, dqChar, dqLit, dqString, escape, identifier, keyword, lineComment, optSep, parse, qArg, regex, semiOrBlock, sep, sqLit, statement, stmtBlock, uArg;

  P = require('comparse');

  YangStatement = (function() {
    function YangStatement(prf1, kw1, arg1, substmts) {
      this.prf = prf1;
      this.kw = kw1;
      this.arg = arg1;
      this.substmts = substmts;
    }

    return YangStatement;

  })();

  lineComment = (P.string('//')).bind(function() {
    return P.anyChar.manyTill(P.char('\n')).bind(function(cs) {
      return P.unit(cs.join(''));
    });
  });

  blockComment = (P.string('/*')).bind(function() {
    return P.anyChar.manyTill(P.string('*/')).bind(function(cs) {
      return P.unit(cs.join(''));
    });
  });

  comment = lineComment.orElse(blockComment);

  sep = (P.space.orElse(comment)).skipMany(1);

  optSep = (P.space.orElse(comment)).skipMany();

  identifier = (P.letter.orElse(P.char('_'))).bind(function(fst) {
    return (P.alphanum.orElse(P.oneOf('.-'))).many().bind(function(tail) {
      var res;
      res = fst + tail.join('');
      return P.unit(res.slice(0, 3).toLowerCase() === 'xml' ? null : res);
    });
  });

  keyword = (identifier.bind(function(prf) {
    return P.char(':').bind(function() {
      return P.unit(prf);
    });
  })).option().bind(function(pon) {
    return identifier.bind(function(kw) {
      return P.unit([pon, kw]);
    });
  });

  uArg = (P.noneOf(" '\"\n\t\r;{}/").orElse(P.char('/').notFollowedBy(P.oneOf('/*')))).concat(1);

  sqLit = P.sat(function(c) {
    return c !== "'";
  }).concat().between(P.char("'"), P.char("'"));

  escape = P.char('\\').bind(function() {
    var esc;
    esc = {
      't': '\t',
      'n': '\n',
      '"': '"',
      '\\': '\\'
    };
    return P.oneOf('tn"\\').bind(function(c) {
      return P.unit(esc[c]);
    }).orElse(regex);
  });

  regex = P.anyChar.bind(function(c) {
    return P.unit("\\" + c);
  });

  dqChar = P.noneOf('"\\').orElse(escape);

  dqLit = P.char('"').bind(function() {
    return P.coordinates.bind(function(col) {
      return dqString(col[1]);
    });
  });

  dqString = function(lim) {
    var trimLead;
    trimLead = function(str) {
      var c, i, left, sptab;
      left = lim;
      sptab = '        ';
      i = 0;
      while (left > 0) {
        c = str[i++];
        if (c === ' ') {
          left -= 1;
        } else if (c === '\t') {
          if (left < 8) {
            return sptab.slice(0, 8 - left) + str.slice(i);
          }
          left -= 8;
        } else {
          return str.slice(i - 1);
        }
      }
      return str.slice(i);
    };
    return dqChar.manyTill(P.char('"')).bind(function(cs) {
      var j, k, len, len1, lines, ln, mo, ref, ref1, res, tlines;
      lines = cs.join('').split('\n');
      tlines = [lines[0]];
      ref = lines.slice(1);
      for (j = 0, len = ref.length; j < len; j++) {
        ln = ref[j];
        tlines.push(trimLead(ln));
      }
      res = [];
      ref1 = tlines.slice(0, -1);
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        ln = ref1[k];
        mo = ln.match(/(.*\S)?\s*/);
        res.push(mo[1]);
      }
      res.push(tlines.pop());
      return P.unit(res.join('\n'));
    });
  };

  qArg = dqLit.orElse(sqLit).bind(function(lft) {
    return (P.char('+').between(optSep, optSep).bind(function() {
      return qArg;
    })).option().bind(function(rt) {
      return P.unit(lft + rt);
    });
  });

  argument = uArg.orElse(qArg);

  statement = keyword.bind(function(kw) {
    return (sep.bind(function() {
      return argument;
    })).option().bind(function(arg) {
      return optSep.bind(function() {
        return semiOrBlock.bind(function(sst) {
          return P.unit(new YangStatement(kw[0], kw[1], arg, sst));
        });
      });
    });
  });

  stmtBlock = P.char('{').bind(function() {
    return (optSep.bind(function() {
      return statement;
    })).manyTill(optSep.bind(function() {
      return P.char('}');
    }));
  });

  semiOrBlock = (P.char(';').bind(function() {
    return P.unit([]);
  })).orElse(stmtBlock);

  parse = function(text, top) {
    var yst;
    if (top == null) {
      top = null;
    }
    yst = statement.between(optSep, optSep).parse(text);
    if ((top != null) && yst.kw !== top) {
      throw P.error("Wrong top-level statement", 0);
    }
    return yst;
  };

  module.exports = {
    parse: parse
  };

}).call(this);
