// Generated by CoffeeScript 1.7.1
(function() {
  var Parser,
    __slice = [].slice;

  Parser = (function() {
    function Parser(pf) {
      this.pf = pf;
    }

    Parser.prototype.parse = function(text) {
      var res;
      Parser.prototype._text = text;
      res = this.pf(0);
      if (res[0] === null) {
        throw Parser.error("Parsing failed", res[1]);
      }
      return res[0];
    };

    Parser.unit = function(v) {
      return new Parser(function(offset) {
        return [v, offset];
      });
    };

    Parser.prototype.bind = function(f) {
      return new Parser((function(_this) {
        return function(offset) {
          var res;
          res = _this.pf(offset);
          if (res[0] === null) {
            return [null, res[1]];
          } else {
            return (f(res[0])).pf(res[1]);
          }
        };
      })(this));
    };

    Parser.prototype.orElse = function(other) {
      return new Parser((function(_this) {
        return function(offset) {
          var res;
          res = _this.pf(offset);
          if (res[0] === null) {
            return other.pf(offset);
          } else {
            return res;
          }
        };
      })(this));
    };

    Parser.choice = function() {
      var p, q;
      p = arguments[0], q = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (q.length === 0) {
        return p;
      } else {
        return p.orElse(Parser.choice.apply(null, q));
      }
    };

    Parser.prototype.many = function(min) {
      if (min == null) {
        min = 0;
      }
      return new Parser((function(_this) {
        return function(offset) {
          var npt, pt, res, val, _ref;
          res = [];
          pt = offset;
          while (true) {
            _ref = _this.pf(pt), val = _ref[0], npt = _ref[1];
            if (val === null) {
              break;
            }
            res.push(val);
            pt = npt;
          }
          if (res.length < min) {
            return [null, npt];
          } else {
            return [res, pt];
          }
        };
      })(this));
    };

    Parser.prototype.concat = function(min) {
      return this.many(min).bind(function(arr) {
        return Parser.unit(arr.join(''));
      });
    };

    Parser.prototype.skipMany = function(min) {
      if (min == null) {
        min = 0;
      }
      return new Parser((function(_this) {
        return function(offset) {
          var cnt, npt, pt, val, _ref;
          cnt = 0;
          pt = offset;
          while (true) {
            _ref = _this.pf(pt), val = _ref[0], npt = _ref[1];
            if (val === null) {
              break;
            }
            cnt++;
            pt = npt;
          }
          if (cnt < min) {
            return [null, npt];
          } else {
            return [cnt, pt];
          }
        };
      })(this));
    };

    Parser.prototype.manyTill = function(end) {
      return new Parser((function(_this) {
        return function(offset) {
          var npt, pt, res, val, _ref, _ref1;
          res = [];
          pt = offset;
          while (true) {
            _ref = end.pf(pt), val = _ref[0], npt = _ref[1];
            if (val !== null) {
              return [res, npt];
            }
            _ref1 = _this.pf(pt), val = _ref1[0], pt = _ref1[1];
            if (val === null) {
              return [null, pt];
            }
            res.push(val);
          }
        };
      })(this));
    };

    Parser.prototype.repeat = function(count) {
      if (count == null) {
        count = 2;
      }
      if (count <= 0) {
        return Parser.unit([]);
      } else {
        return this.bind((function(_this) {
          return function(head) {
            return _this.repeat(count - 1).bind(function(tail) {
              tail.unshift(head);
              return Parser.unit(tail);
            });
          };
        })(this));
      }
    };

    Parser.prototype.between = function(lft, rt) {
      return lft.bind((function(_this) {
        return function() {
          return _this.bind(function(res) {
            return rt.bind(function() {
              return Parser.unit(res);
            });
          });
        };
      })(this));
    };

    Parser.prototype.option = function(dflt) {
      if (dflt == null) {
        dflt = '';
      }
      return this.orElse(Parser.unit(dflt));
    };

    Parser.prototype.sepBy = function(sep, min) {
      if (min == null) {
        min = 0;
      }
      if (min === 0) {
        return this.sepBy(sep, 1).orElse(Parser.unit([]));
      } else {
        return this.bind((function(_this) {
          return function(head) {
            return (sep.bind(function() {
              return _this;
            })).many(min - 1).bind(function(tail) {
              tail.unshift(head);
              return Parser.unit(tail);
            });
          };
        })(this));
      }
    };

    Parser.prototype.endBy = function(sep, min) {
      if (min == null) {
        min = 0;
      }
      return (this.bind(function(x) {
        return sep.bind(function() {
          return Parser.unit(x);
        });
      })).many(min);
    };

    Parser.prototype.sepEndBy = function(sep, min) {
      if (min == null) {
        min = 0;
      }
      return this.sepBy(sep, min).bind(function(res) {
        return sep.option().bind(function() {
          return Parser.unit(res);
        });
      });
    };

    Parser.prototype.notFollowedBy = function(p) {
      return this.bind(function(res) {
        return new Parser(function(offset) {
          var val;
          val = (p.pf(offset))[0] === null ? res : null;
          return [val, offset];
        });
      });
    };

    Parser.eof = new Parser(function(offset) {
      var res;
      res = offset >= this._text.length ? true : null;
      return [res, offset];
    });

    Parser.anyChar = new Parser(function(offset) {
      var next;
      next = this._text[offset++];
      if (next != null) {
        return [next, offset];
      } else {
        return [null, offset];
      }
    });

    Parser.sat = function(pred) {
      return Parser.anyChar.bind(function(x) {
        if (pred(x)) {
          return Parser.unit(x);
        } else {
          return new Parser(function(offset) {
            return [null, offset - 1];
          });
        }
      });
    };

    Parser.char = function(ch) {
      return Parser.sat(function(x) {
        return ch === x;
      });
    };

    Parser.oneOf = function(alts) {
      return Parser.sat(function(x) {
        return alts.indexOf(x) >= 0;
      });
    };

    Parser.noneOf = function(alts) {
      return Parser.sat(function(x) {
        return alts.indexOf(x) === -1;
      });
    };

    Parser.lower = Parser.sat(function(x) {
      return /^[a-z]$/.test(x);
    });

    Parser.upper = Parser.sat(function(x) {
      return /^[A-Z]$/.test(x);
    });

    Parser.alphanum = Parser.sat(function(x) {
      return /^\w$/.test(x);
    });

    Parser.space = Parser.sat(function(x) {
      return /^\s$/.test(x);
    });

    Parser.digit = Parser.oneOf('0123456789');

    Parser.octDigit = Parser.oneOf('01234567');

    Parser.hexDigit = Parser.oneOf('01234567abcdefABCDEF');

    Parser.nat0 = Parser.digit.concat(1).bind(function(ds) {
      return Parser.unit(Number(ds));
    });

    Parser.letter = Parser.lower.orElse(Parser.upper);

    Parser.skipSpace = Parser.space.skipMany();

    Parser.string = function(str) {
      return new Parser(function(offset) {
        if (str === this._text.substr(offset, str.length)) {
          return [str, offset + str.length];
        } else {
          return [null, offset];
        }
      });
    };

    Parser.offset = new Parser(function(offset) {
      return [offset, offset];
    });

    Parser.offset2coords = function(offset, tab) {
      var beg, expTab, lf, ln;
      if (tab == null) {
        tab = 8;
      }
      expTab = function(from, to) {
        var c, cnt, _i, _len, _ref;
        cnt = 0;
        _ref = Parser.prototype._text.slice(from, to);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          cnt += c === '\t' ? tab : 1;
        }
        return cnt;
      };
      ln = 1;
      beg = 0;
      while (true) {
        lf = Parser.prototype._text.indexOf('\n', beg);
        if (lf === -1 || lf >= offset) {
          break;
        }
        ln += 1;
        beg = lf + 1;
      }
      return [ln, expTab(beg, offset)];
    };

    Parser.coordinates = new Parser(function(offset) {
      return [Parser.offset2coords(offset), offset];
    });

    Parser.error = function(msg, offset) {
      var res;
      res = new Error(msg);
      res.name = 'ParsingError';
      res.offset = offset;
      res.coords = this.offset2coords(offset);
      return res;
    };

    return Parser;

  })();

  if (module.exports != null) {
    module.exports = Parser;
  } else {
    this.Parser = Parser;
  }

}).call(this);
