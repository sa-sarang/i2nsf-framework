module ietf-i2nsf-capability-interface {
  namespace "http://skku.com/iot/example/ietf-i2nsf-capability-interface";
  prefix nsf-facing-interface;
  import ietf-inet-types {
    prefix inet;
  }

  import ietf-yang-types {
    prefix yang;
  }

  import tailf-common {
	prefix tailf;
  } 

  organization
    "IETF I2NSF (Interface to Network Security Functions)
    Working Group";

  contact
    "WG Web: <http://tools.ietf.org/wg/i2nsf>
     WG List: <mailto:i2nsf@ietf.org>

     WG Chair: Adrian Farrel
     <mailto:Adrain@olddog.co.uk>

     WG Chair: Linda Dunbar
     <mailto:Linda.duhbar@huawei.com>

     Editor: Jingyong Tim Kim
     <mailto:wlsdyd0930@nate.com>
    
     Editor: Jaehoon Paul Jeong
     <mailto:pauljeong@skku.edu>

     Editor: Susan Hares
     <mailto:shares@ndzh.com>";

  description
    "This module defines a YANG data module for network security
     functions.";
  revision "2016-10-31"{
    description "Initial revision";
    reference
	  "draft-xia-i2nsf-capability-interface-im-06
	   draft-jeong-i2nsf-capability-interface-yang-03.txt";
  }


  container policy {
	tailf:callpoint hcp;
	description
	 "policy is a grouping
		including a set of security rules according to certain logic,
		i.e., their similarity or mutual relations, etc. The network
		security policy is able to apply over both the unidirectional	
		and bidirectional traffic across the NSF.";

	
	
	leaf policy-name {
		type string;
		mandatory true;
	 	description
		  "The name of the policy.
		   This must be unique.";
	}
	
	leaf policy-id {
		type string;
		mandatory true;
		description
		"The ID of the policy.
		This must be unique.";
	}

	list rules {
		key "rule-id";
		description
		  "This is a rule for network security control.";
		max-elements 64;
		
		leaf rule-name {
			type string;
			mandatory true;
			description
			  "The name of the rule.
			   This must be unique.";
		}

		leaf rule-id {
			type uint32;
			mandatory true;
			description
			  "The ID of the rule.
			   This is key for rule-list.
			   This must be unique.";
		}
	
		container event {
			description
			" An Event is defined as any important occurrence in time
			of a change in the system being managed, and/or in the
			environment of the system being managed. When used in
			the context of policy rules for a flow-based NSF, it is
			used to determine whether the Condition clause of the
			Policy Rule can be evaluated or not. Examples of an
			I2NSF Event include time and user actions (e.g., logon,
			logoff, and actions that violate any ACL.).";
			list user-security-event {
				key usr-sec-event-id;
				description
				"The purpose of this class is to represent Events that
				are initiated by a user, such as logon and logoff
				Events. Information in this Event may be used as part
				of a test to determine if the Condition clause in
				this ECA Policy Rule should be evaluated or not.
				Examples include user identification data and the
				type of connection used by the user.";

				leaf usr-sec-event-id {
					type uint32;
					mandatory true;
					description
					"The ID of the usr-sec-event.
					This is key for usr-sec-event-list.
					This must be unique.";
				}

				leaf usr-sec-event-content {
					type string;
					mandatory true;
					description
					"This is a mandatory string that contains the content
					of the UserSecurityEvent. The format of the content
					is specified in the usrSecEventFormat class
					attribute, and the type of Event is defined in the
					usrSecEventType class attribute. An example of the
					usrSecEventContent attribute is a string hrAdmin,
					with the usrSecEventFormat set to 1 (GUID) and the
					usrSecEventType attribute set to 5 (new logon).";
				}

				leaf usr-sec-event-format {
					type uint32;
					mandatory true;
					description
					"This is a mandatory uint 8 enumerated integer,which
					is used to specify the data type of the
					usrSecEventContent attribute. The content is
					specified in the usrSecEventContent class attribute,
					and the type of Event is defined in the
					usrSecEventType class attribute. An example of the
					usrSecEventContent attribute is string hrAdmin,
					with the usrSecEventFormat attribute set to 1 (GUID)
					and the usrSecEventType attribute set to 5
					(new logon).";
				}

				leaf usr-sec-event-type {
					type uint32;
					mandatory true;
					description
					"This is a mandatory uint 8 enumerated integer, which
					is used to specify the type of Event that involves
					this user. The content and format are specified in
					the usrSecEventContent and usrSecEventFormat class
					attributes, respectively. An example of the
					usrSecEventContent attribute is string hrAdmin,
					with the usrSecEventFormat attribute set to 1 (GUID)
					and the usrSecEventType attribute set to 5
					(new logon).";
				}
			}
		
			list device-security-event {
				key dev-sec-event-id;
				description
				"The purpose of a DeviceSecurityEvent is to represent
				Events that provide information from the Device that
				are important to I2NSF Security. Information in this
				Event may be used as part of a test to determine if
				the Condition clause in this ECA Policy Rule should be
				evaluated or not. Examples include alarms and various
				device statistics (e.g., a type of threshold that was
				exceeded), which may signal the need for further
				action.";

				leaf dev-sec-event-id {
					type uint32;
					mandatory true;
					description
					"The ID of the dev-sec-event.
					This is key for dev-sec-event-list.
					This must be unique.";
				}

				leaf dev-sec-event-content {
					type string;
					mandatory true;
					description
					"This is a mandatory string that contains the content
					of the DeviceSecurityEvent.The format of the content
					is specified in the devSecEventFormat class
					attribute, and the type of Event is defined in the
					devSecEventType class attribute. An example of the
					devSecEventContent attribute is alarm, with the
					devSecEventFormat attribute set to 1 (GUID), the
					devSecEventType attribute set to 5 (new logon).";
				}

				leaf dev-sec-event-format {
					type uint32;
					mandatory true;
					description
					"This is a mandatory uint 8 enumerated integer, which
					is used to specify the data type of the
					devSecEventContent attribute.";
				}

				leaf dev-sec-event-type {
					type uint32;
					mandatory true;
					description
					"This is a mandatory uint 8 enumerated integer, which
					is used to specify the type of Event that was
					generated by this device.";
				}
				leaf dev-sec-event-type-severity {
					type uint32;
					mandatory true;
					description
					"This is a mandatory uint 8 enumerated integer, which
					is used to specify the perceived severity of the
					Event generated by this Device.";
				}
			}
			
			list system-security-event {
				key sys-sec-event-id;
				description
				"The purpose of a SystemSecurityEvent is to represent
				Events that are detected by the management system,
				instead of Events that are generated by a user or a
				device. Information in this Event may be used as part
				of a test to determine if the Condition clause in
				this ECA Policy Rule should be evaluated or not.
				Examples include an event issued by an analytics
				system that warns against a particular pattern of
				unknown user accesses, or an Event issued by a
				management system that represents a set of correlated
				and/or filtered Events.";

				leaf sys-sec-event-id {
					type uint32;
					mandatory true;
					description
					"The ID of the sys-sec-event.
					This is key for sys-sec-event-list.
					This must be unique.";
				}

				leaf sys-sec-event-content {
					type string;
					mandatory true;
					description
					"This is a mandatory string that contains a content
					of the SystemSecurityEvent. The format of a content
					is specified in a sysSecEventFormat class attribute,
					and the type of Event is defined in the
					sysSecEventType class attribute. An example of the
					sysSecEventContent attribute is string sysadmin3,
					with the sysSecEventFormat attribute set to 1(GUID),
					and the sysSecEventType attribute set to 2
					(audit log cleared).";
				}

				leaf sys-sec-event-format {
					type uint32;
					mandatory true;
					description
					"This is a mandatory uint 8 enumerated integer, which
					is used to specify the data type of the
					sysSecEventContent attribute.";
				}

				leaf sys-sec-event-type {
					type uint32;
					mandatory true;
					description
					"This is a mandatory uint 8 enumerated integer, which
					is used to specify the type of Event that involves
					this device.";
				}
			}

			list time-security-event {
				key time-sec-event-id;
				description
				"Purpose of a TimeSecurityEvent is to represent Events
				that are temporal in nature (e.g., the start or end of
				a period of time). Time events signify an individual
				occurrence, or a time period, in which a significant
				event happened. Information in the Event may be used as
				part of a test to determine if the Condition clause in
				this ECA Rule should be evaluated or not. Examples
				include issuing an Event at a specific time to indicate
				that a particular resource should not be accessed, or
				that different authentication and authorization
				mechanisms should now be used (e.g., because it is now
				past regular business hours).";

				leaf time-sec-event-id {
					type uint32;
					mandatory true;
					description
					"The ID of the time-sec-event.
					This is key for time-sec-event-list.
					This must be unique.";
				}
				leaf time-sec-event-period-begin {
					type string;
					mandatory true;
					description
					"This is a mandatory DateTime attribute, and
					represents the beginning of a time period.
					It has a value that has a date and/or a time
					component (as in the Java or Python libraries).";
				}
				leaf time-sec-event-period-end {
					type string;
					mandatory true;
					description
					"This is a mandatory DateTime attribute, and
					represents the end of a time period. It has
					a value that has a date and/or a time component
					(as in the Java or Python libraries). If this is
					a single Event occurrence, and not a time period
					when the Event can occur, then the
					timeSecEventPeriodEnd attribute may be ignored.";
				}
				leaf time-sec-event-time-zone {
					type string;
					mandatory true;
					description
					"This is a mandatory string attribute, and defines a
					time zone that this Event occurred in using the
					format specified in ISO8601.";
				}
			}

		}

		container condition {
			description
			"TBD";
			container packet-security-condition {
				description
				"The purpose of this Class is to represent packet header
				information that can be used as part of a test to
				determine if the set of Policy Actions in this ECA
				Policy Rule should be executed or not. This class is
				abstract, and serves as the superclass of more detailed
				conditions that involve different types of packet
				formats.";

				list packet-security-mac-condition {
					key pkt-sec-cond-mac-id;
					description
					"The purpose of this Class is to represent packet MAC
					packet header information that can be used as part of
					a test to determine if the set of Policy Actions in
					this ECA Policy Rule should be executed or not.";

					leaf pkt-sec-cond-mac-id {
						type uint32;
						mandatory true;
						description
						"The ID of the pkt-sec-cond-mac.
						This is key for pkt-sec-cond-mac-list.
						This must be unique.";
					}
					leaf pkt-sec-cond-mac-dest {
						type inet:port-number;
						mandatory true;
						description
						"This is a mandatory uint 32 attribute, and defines
						the MAC destination address (6 octets long).";
					}
					leaf pkt-sec-cond-mac-src {
						type inet:port-number;
						mandatory true;
						description
						"This is a mandatory uint 32 attribute, and defines
						the MAC source address (6 octets long).";
					}
					leaf pkt-sec-cond-mac-8021q {
						type string;
						mandatory true;
						description
						"This is an optional string attribute, and defines
						the 802.1Q tag value (2 octets long). This defines
						VLAN membership and 802.1p priority values.";
					}
					leaf pkt-sec-cond-mac-ether-type {
						type string;
						mandatory true;
						description
						"This is a mandatory string attribute, and defines
						the EtherType field (2 octets long). Values up to
						and including 1500 indicate the size of the payload
						in octets; values of 1536 and above define which
						protocol is encapsulated in the payload of the
						frame.";
					}
					leaf pkt-sec-cond-mac-tci {
						type string;
						mandatory true;
						description
						"This is an optional string attribute, and defines
						the Tag Control Information. This consists of a 3
						bit user priority field, a drop eligible indicator
						(1 bit), and a VLAN identifier (12 bits).";
					}
				} 
					
				list packet-security-ipv4-condition {
					key pkt-sec-cond-ipv4-id;
					description
					"The purpose of this Class is to represent packet IPv4
					packet header information that can be used as part of
					a test to determine if the set of Policy Actions in
					this ECA Policy Rule should be executed or not.";

					leaf pkt-sec-cond-ipv4-id {
						type uint32;
						mandatory true;
						description
						"The ID of the pkt-sec-cond-ipv4.
						This is key for pkt-sec-cond-ipv4-list.
						This must be unique.";
					}

					leaf-list pkt-sec-cond-ipv4-src {
						type inet:ip-address;
						description
						"This is a mandatory inet:ipv4-address attribute,
						and defines the IPv4 Source Address (32 bits).";
						min-elements 0;
						max-elements 50;
					}
					leaf-list pkt-sec-cond-ipv4-dest {
						type inet:ip-address;
						description
						"This is a mandatory inet:ipv4-address attribute,
						and defines the IPv4 Destination Address
						(32 bits).";
						min-elements 0;
						max-elements 50;
					}
					leaf pkt-sec-cond-ipv4-protocol {
						type string;
						description
						"This is a mandatory string attribute, and defines
						he protocol used in the data portion of the IP
						datagram (8 bits).";
					}
					leaf pkt-sec-cond-ipv4-dscp {
						type string;
						description
						"This is a mandatory string attribute, and defines
						the Differentiated Services Code Point field
						(6 bits).";
					}
					leaf pkt-sec-cond-ipv4-ecn {
						type string;
						description
						"This is an optional string attribute, and defines
						the Explicit Congestion Notification field
						(2 bits).";
					}
					leaf pkt-sec-cond-ipv4-length {
						type string;
						description
						"This is a mandatory string attribute, and defines
						the total length of the packet (including header
						and data) in bytes (16 bits).";
					}
					leaf pkt-sec-cond-ipv4-ttl {
						type string;
						description
						"This is a mandatory string attribute, and defines
						the Time To Live in seconds (8 bits).";
					}
				}

				list packet-security-ipv6-condition {
					key pkt-sec-cond-ipv6-id;
					description
					"The purpose of this Class is to represent packet
					IPv6 packet header information that can be used as
					part of a test to determine if the set of Policy
					Actions in this ECA Policy Rule should be executed
					or not.";
					
					leaf pkt-sec-cond-ipv6-id {
						type uint32;
						mandatory true;
						description
						"The ID of the pkt-sec-cond-ipv6.
						This is key for pkt-sec-cond-ipv6-list.
						This must be unique.";
					}
					leaf-list pkt-sec-cond-ipv6-src {
						type inet:ipv6-address;
						min-elements 0;
						max-elements 50;
						description
						"This is a mandatory inet:ipv6-address attribute,
						and defines the IPv6 Source Address (128 bits).";
					}
					leaf-list pkt-sec-cond-ipv6-dest {
						type inet:ipv6-address;
						min-elements 0;
						max-elements 50;
						description
						"This is a mandatory inet:ipv6-address attribute,
						and defines the IPv6 Destination Address
						(128 bits).";
					}
					leaf pkt-sec-cond-ipv6-dscp {
						type string;
						mandatory true;
						description
						"This is a mandatory string attribute, and defines
						the Differentiated Services Code Point field
						(6 bits). It consists of the six most significant
						bits of the Traffic Class field in the IPv6
						header.";
					}
					leaf pkt-sec-cond-ipv6-ecn {
						type string;
						mandatory true;
						description
						"This is a mandatory string attribute, and defines
						the Explicit Congestion Notification field (2 bits).
						It consists of the two least significant bits of
						the Traffic Class field in the IPv6 header.";
					}
					leaf pkt-sec-cond-ipv6-flow-label {
						type string;
						mandatory true;
						description
						"This is a mandatory string attribute, and defines
						an IPv6 flow label. This, in combination with the
						Source and Destination Address fields, enables
						efficient IPv6 flow classification by using only
						the IPv6 main header fields (20 bits).";
					}
					leaf pkt-sec-cond-ipv6-payload-length {
						type string;
						mandatory true;
						description
						"This is a mandatory string attribute, and defines
						the total length of the packet (including the
						fixed and any extension headers, and data) in
						bytes (16 bits).";
					}
					leaf pkt-sec-cond-ipv6-next-header {
						type string;
						mandatory true;
						description
						"This is a mandatory string attribute, and defines
						the type of the next header (e.g., which extension
						header to use) (8 bits).";
					}
					leaf pkt-sec-cond-ipv6-hop-limit {
						type string;
						mandatory true;
						description
						"This is a mandatory string attribute, and defines
						the maximum number of hops that this packet can
						traverse (8 bits).";
					}
				}

				list packet-security-tcp-condition {
					key pkt-sec-cond-tcp-id;
					description
					"The purpose of this Class is to represent packet
					TCP packet header information that can be used as
					part of a test to determine if the set of Policy
					Actions in this ECA Policy Rule should be executed
					or not.";
	
					leaf pkt-sec-cond-tcp-id {
						type uint32;
						mandatory true;
						description
						"The ID of the pkt-sec-cond-tcp.
						This is key for pkt-sec-cond-tcp-list.
						This must be unique.";
					}
					leaf pkt-sec-cond-tcp-src-port {
						type inet:port-number;
						mandatory true;
						description
						"This is a mandatory port attribute, and defines
						the Source Port (16 bits).";
					}
					leaf pkt-sec-cond-tcp-dest-port {
						type inet:port-number;
						mandatory true;
						description
						"This is a mandatory port attribute, and defines
						the Destination Port (16 bits).";
					}
					leaf pkt-sec-cond-tcp-seq-num {
						type string;
						mandatory true;
						description
						"This is a mandatory string attribute, and defines
						the sequence number (32 bits).";
					}
					leaf pkt-sec-cond-tcp-flags {
						type string;
						mandatory true;
						description
						"This is a mandatory string attribute, and defines
						the nine Control bit flags (9 bits).";
					}
				}
				list packet-security-udp-condition {
					key pkt-sec-cond-udp-id;
					description
					"The purpose of this Class is to represent packet UDP
					packet header information that can be used as part
					of a test to determine if the set of Policy Actions
					in this ECA Policy Rule should be executed or not.";
					leaf pkt-sec-cond-udp-id {
						type uint32;
						mandatory true;
						description
						"The ID of the pkt-sec-cond-udp.
						This is key for pkt-sec-cond-udp-list.
						This must be unique.";
					}
					leaf pkt-sec-cond-udp-src-port {
						type inet:port-number;
						mandatory true;
						description
						"This is a mandatory port attribute, and defines
						the UDP Source Port (16 bits).";
					}
					leaf pkt-sec-cond-udp-dest-port {
						type inet:port-number;
						mandatory true;
						description
						"This is a mandatory port attribute, and defines
						the UDP Destination Port (16 bits).";
					}
					leaf pkt-sec-cond-udp-length {
						type string;
						mandatory true;
						description
						"This is a mandatory string attribute, and defines
						the length in bytes of the UDP header and data
						(16 bits).";
					}
				}
			}

			list packet-payload-security-condition {
				key "pkt-payload-id";
				description
				"The ID of the pkt-payload.
				This is key for pkt-payload-list.
				This must be unique.";
				leaf pkt-payload-id {
					type uint32;
					mandatory true;
					description
					"The ID of the packet payload.
					This must be unique.";
				}
			}

			list target-security-condition {
				key "target-sec-cond-id";
				description
				"Under the circumstances of network, it mainly
				refers to the service, application, and device.";
				leaf target-sec-cond-id {
					type uint32;
					mandatory true;
					description
					"The ID of the target.
					This must be unique.";
				}
				container service-sec-context-cond{
					description
					"A service is an application identified by a
					protocol type and port number, such as TCP,
					UDP, ICMP, and IP.";

					leaf service-sec-context-cond-name {
						type string;
						mandatory true;
						description
						"The name of the service.
						This must be unique.";
					}
					leaf service-sec-context-cond-id {
						type uint32;
						mandatory true;
						description
						"The ID of the service.
						This must be unique.";
					}
					container protocol {
						description
						"Protocol types:
						TCP, UDP, ICMP, ICMPv6, IP, and etc.";
						leaf service-sec-context-cond-protocol-tcp {
							type boolean;
							mandatory true;
							description
							"TCP protocol type.";
						}
						leaf service-sec-context-cond-protocol-udp {
							type boolean;
							mandatory true;
							description
							"UDP protocol type.";
						}
						leaf service-sec-context-cond-protocol-icmp {
							type boolean;
							mandatory true;
							description
							"ICMP protocol type.";
						}
						leaf service-sec-context-cond-protocol-icmpv6 {
							type boolean;
							mandatory true;
							description
							"ICMPv6 protocol type.";
						}
						leaf service-sec-context-cond-protocol-ip {
							type boolean;
							mandatory true;
							description
							"IP protocol type.";
						}
					}
					leaf service-sec-context-cond-src-port{
						type inet:port-number;
						description
						"It can be used for finding programs.";
					}
					leaf service-sec-context-cond-dest-port{
						type inet:port-number;
						description
						"It can be used for finding programs.";
					}
				}
				container application-sec-context-cond {
					description
					"An application is a computer program for
					a specific task or purpose. It provides
					a finer granularity than service in matching
					traffic.";
					leaf app-sec-context-cond-name{
						type string;
						mandatory true;
						description
						"The name of the application.
						This must be unique.";
					}
					leaf app-sec-context-cond-id{
						type uint32;
						mandatory true;
						description
						"The ID of the application.
						This must be unique.";
					}
					container category {
						description
						"Category types: Business system, Entertainment,
						Interest, Network, General, and etc.";

						leaf business-system {
							type boolean;
							description
							"Business system category.";
						}
						leaf entertainment {
							type boolean;
							description
							"Entertainment category.";
						}
						leaf interest {
							type boolean;
							description
							"Interest category.";
						}
						leaf network {
							type boolean;
							description
							"Network category.";
						}
						leaf general {
							type boolean;
							description
							"General category.";
						}
					}
					container subcategory{
						description
						"Subcategory types: Finance, Email, Game,
						Media sharing, Social network, Web posting,
						and etc.";
						leaf finance {
							type boolean;
							description
							"Finance subcategory.";
						}
						leaf email {
							type boolean;
							description
							"Email subcategory.";
						}
						leaf game {
							type boolean;
							description
							"Game subcategory.";
						}
						leaf media-sharing {
							type boolean;
							description
							"Media sharing subcategory.";
						}
						leaf social-network {
							type boolean;
							description
							"Social network subcategory.";
						}
						leaf web-posting {
							type boolean;
							description
							"Web posting subcategory.";
						}
					}
					container data-transmission-model{
						description
						"Data transmission model types: Client-server,
						Browser-based, Networking, Peer-to-Peer,
						Unassigned, and etc.";

						leaf client-server {
							type boolean;
							description
							"client-server data transmission model.";
						}
						leaf browser-based {
							type boolean;
							description
							"Browser-based data transmission model.";
						}
						leaf networking {
							type boolean;
							description
							"Networking data transmission model.";
						}
						leaf peer-to-peer {
							type boolean;
							description
							"Peer-to-Peer data transmission model.";
						}
						leaf unassigned {
							type boolean;
							description
							"Unassigned data transmission model.";
						}
					}
					container risk-level{
						description
						"Risk level types: Exploitable,
						Productivity loss, Evasive, Data loss,
						Malware vehicle, Bandwidth consuming,
						Tunneling, and etc.";
						leaf exploitable {
							type boolean;
							description
							"Exploitable risk level.";
						}
						leaf productivity-loss {
							type boolean;
							description
							"Productivity loss risk level.";
						}
						leaf evasive {
							type boolean;
							description
							"Evasive risk level.";
						}
						leaf data-loss {
							type boolean;
							description
							"Data loss risk level.";
						}
						leaf malware-vehicle {
							type boolean;
							description
							"Malware vehicle risk level.";
						}
						leaf bandwidth-consuming {
							type boolean;
							description
							"Bandwidth consuming risk level.";
						}
						leaf tunneling {
							type boolean;
							description
							"Tunneling risk level.";
						}
					}
				}
				container device-sec-context-cond {
					description
					"The device attribute that can identify a device,
					including the device type (i.e., router, switch,
					pc, ios, or android) and the device’s owner as
					well.";
					leaf pc {
						type boolean;
						description
						"If type of a device is PC.";
					}
					leaf mobile-phone {
						type boolean;
						description
						"If type of a device is mobile-phone.";
					}
					leaf tablet {
						type boolean;
						description
						"If type of a device is tablet.";
					}
					leaf voip-volte-phone {
						type boolean;
						description
						"If type of a device is voip-volte-phone.";
					}
				}
			}

			list user-security-cond {
				key "usr-sec-cond-id";
				description
				"TBD";

				leaf usr-sec-cond-id {
					type uint32;
					description
					"The ID of the user-sec-cond.
					This is key for user-sec-cond-list.
					This must be unique.";
				}
				container user{
					description
					"The user (or user group) information with which
					network flow is associated: The user has many
					attributes such as name, id, password, type,
					authentication mode and so on. Name/id is often
					used in the security policy to identify the user.
					Besides, NSF is aware of the IP address of the
					user provided by a unified user management system
					via network. Based on name-address association,
					NSF is able to enforce the security functions
					over the given user (or user group)";

					choice user-name {
						description
						"The name of the user.
						This must be unique.";
						case tenant {
							description
							"Tenant information.";
							leaf user-tenant {
								type uint32;
								mandatory true;
								description
								"User’s tenant information.";
							}
						}
						case vn-id {
							description
							"VN-ID information.";
							leaf user-vn-id {
								type uint32;
								mandatory true;
								description
								"User’s VN-ID information.";
							}
						}
					}
				}
				container group {
					description
					"The user (or user group) information with which
					network flow is associated: The user has many
					attributes such as name, id, password, type,
					authentication mode and so on. Name/id is often
					used in the security policy to identify the user.
					Besides, NSF is aware of the IP address of the
					user provided by a unified user management system
					via network. Based on name-address association,
					NSF is able to enforce the security functions
					over the given user (or user group)";

					choice group-name {
						description
						"The name of the user.
						This must be unique.";
						case tenant {
							description
							"Tenant information.";
							leaf group-tenant {
								type uint32;
								mandatory true;
								description
								"User’s tenant information.";
							}
						}
						case vn-id {
							description
							"VN-ID information.";
							leaf group-vn-id {
								type uint32;
								mandatory true;
								description
								"User’s VN-ID information.";
							}
						}
					}					 
				}
			}


			list generic-context-condition {
				key "gen-context-cond-id";
				description
				"TBD";
				leaf gen-context-cond-id {
					type uint32;
					description
					"The ID of the gen-context-cond.
					This is key for gen-context-cond-list.
					This must be unique.";
				}
				container schedule {
					leaf start-time {
						type string;
						units 24-hour-clock;
					}
					leaf end-time {
						type string;
						units 24-hour-clock;
					}
				}
				container geographic-location {
					description
					"The location where network traffic is associated
					with. The region can be the geographic location
					such as country, province, and city,
					as well as the logical network location such as
					IP address, network section, and network domain.";
					leaf-list geographic-location {
						type uint32;
						min-elements 0;
						max-elements 50;
						description
						"This is mapped to ip address. We can acquire
						region through ip address stored the database.";
					}
				}
			}
		}
		container action {
			description
			"TBD.";
			container action-type {
				description
				"The flow-based NSFs realize the network security
				functions by executing various Actions, which at least
				includes ingress-action, egress-action, and
				advanced-action.";

				container ingress-action {
					description
					"The ingress actions consist of permit, deny,
					and mirror.";
						leaf permit {
							type boolean;
							description
								"Packet flow is permitted.";
						}
						leaf deny {
							type boolean;
							description
							"Packet flow is denied.";
						}
						leaf mirror {
							type boolean;
							description
								"Packet flow is mirroried.";
						}
				}

				container egress-action {
					description
					"The egress actions consist of invoke-signaling,
					tunnel-encapsulation, and forwarding.";
					choice egress-action-type {
						description
						"Egress-action-type: invoke-signaling,
						tunnel-encapsulation, and forwarding.";
						case invoke-signaling {
							description
							"Invoke-signaling case.";
							leaf invoke-signaling {
								type boolean;
								mandatory true;
								description
								"TBD.";
							}
						}
						case tunnel-encapsulation {
							description
							"tunnel-encapsulation case.";
							leaf tunnel-encapsulation {
								type boolean;
								mandatory true;
								description
								"TBD.";
							}
						}
						case forwarding {
							description
							"forwarding case.";
							leaf forwarding {
								type boolean;
								mandatory true;
								description
								"TBD.";
							}
						}
					}
				}
				
				container apply-profile-action {
					description
					"Applying a specific Functional Profile or signature
					- e.g., an IPS Profile, a signature file, an
					anti-virus file, or a URL filtering file. The
					functional profile or signature file corresponds to
					the security capability for the content security
					control and attack mitigation control which will be
					described afterwards. It is one of the key properties
					that determine the effectiveness of the NSF, and is
					mostly vendor specific today. One goal of I2NSF is
					to standardize the form and functional interface of
					those security capabilities while supporting vendor-
					specific implementations of each.";
					choice apply-profile-action-type {
						description
						"Advanced action types: Content Security Control
						and Attack Mitigation Control.";
						case content-security-control {
							description
							"Content security control is another category of
							security capabilities applied to application layer.
							Through detecting the contents carried over the
							traffic in application layer, these capabilities
							can realize various security purposes, such as
							defending against intrusion, inspecting virus,
							filtering malicious URL or junk email, and blocking
							illegal web access or data retrieval.";
							container content-security-control-types {
								description
								"Content Security types: Antivirus, IPS, IDS,
								url-filtering, data-filtering, mail-filtering,
								file-blocking, file-isolate, pkt-capture,
								application-control, and voip-volte.";
							
								container antivirus {
									description
									"Antivirus is computer software used to
									prevent, detect and remove malicious
									software.";
									leaf antivirus-insp {
										type boolean;
										description
										"Additional inspection of antivirus.";
									}
								}
								container ips {
									description
									"Intrusion prevention systems (IPS) are
									network security appliances that monitor
									network and/or system activities for
									malicious activities.";
									leaf ips-insp {
										type boolean;
										description
										"Additional inspection of IPS.";
									}
								}
								container ids {
									description
									"IDS security service.";
									leaf ids-insp {
										type boolean;
										description
										"Additional inspection of IDS.";
									}
								}
								container url-filtering {
									description
									"URL filtering security service.";
									leaf url-filtering-insp {
										type boolean;
										description
										"Additional inspection of URL filtering.";
									}
								}
								container data-filtering {
									description
									"Data filtering security service.";
									leaf data-filtering-insp {
										type boolean;
										description
										"Additional inspection of data filtering.";
									}
								}
								container mail-filtering {
									description
									"Mail filtering security service.";
									leaf mail-filtering-insp {
										type boolean;
										description
										"Additional inspection of mail filtering.";
									}
								}
								container file-blocking {
									description
									"File blocking security service.";
									leaf file-blocking-insp {
										type boolean;
										description
										"Additional inspection of file blocking.";
									}
								}
								container file-isolate {
									description
									"File isolate security service.";
									leaf file-isolate-insp {
										type boolean;
										description
										"Additional inspection of file isolate.";
									}
								}
								container pkt-capture {
									description
									"Packet capture security service.";
									leaf pkt-capture-insp {
										type boolean;
										description
										"Additional inspection of packet capture.";
									}
								}
								container application-control {
									description
									"app-control security service.";
									leaf application-control-insp {
										type boolean;
										description
										"Additional inspection of app control.";
									}
								}
								container voip-volte {
									description
									"VoIP/VoLTE security service.";
									leaf voip-volte-insp {
										type boolean;
										description
										"Additional inspection of VoIP/VoLTE.";
									}
								}
							}
						}
						case attack-mitigation-control {
							description
							"This category of security capabilities is
							specially used to detect and mitigate various
							types of network attacks.";
							choice attack-mitigation-control-type {
								description
								"Attack-mitigation types: DDoS-attack and
								Single-packet attack.";
								case ddos-attack {
									description
									"A distributed-denial-of-service (DDoS) is
									where the attack source is more than one,
									often thousands of unique IP addresses.";
									choice ddos-attack-type {
										description
										"DDoS-attack types: Network Layer DDoS Attacks
										and Application Layer DDoS Attacks.";
										case network-layer-ddos-attack {
											description
											"Network layer DDoS-attack.";
											container network-layer-ddos-attack-types {
												description
												"Network layer DDoS attack types:
												Syn Flood Attack, UDP Flood Attack,
												ICMP Flood Attack, IP Fragment Flood,
												IPv6 Related Attacks, and etc";
												container syn-flood-attack {
													description
													"If the network layer DDoS-attack is
													a syn flood attack.";
													leaf syn-flood-insp {
														type boolean;
														mandatory true;
														description
														"Additional Inspection of
														Syn Flood Attack.";
													}
												}
												container udp-flood-attack {
													description
													"If the network layer DDoS-attack is
													a udp flood attack.";
													leaf udp-flood-insp {
														type boolean;
														mandatory true;
														description
														"Additional Inspection of
														UDP Flood Attack.";
													}
												}
												container icmp-flood-attack {
													description
													"If the network layer DDoS-attack is
													an icmp flood attack.";
													leaf icmp-flood-insp {
														type boolean;
														mandatory true;
														description
														"Additional Inspection of
														ICMP Flood Attack.";
													}
												}
												container ip-frag-flood-attack {
													description
													"If the network layer DDoS-attack is
													an ip fragment flood attack.";
													leaf ip-frag-flood-insp {
														type boolean;
														mandatory true;
														description
														"Additional Inspection of
														IP Fragment Flood.";
													}
												}
												container ipv6-related-attacks {
													description
													"If the network layer DDoS-attack is
													ipv6 related attacks.";
													leaf ipv6-related-insp {
														type boolean;
														mandatory true;
														description
														"Additional Inspection of
														IPv6 Related Attacks.";
													}
												}
											}
										}
										case app-layer-ddos-attack {
											description
											"Application layer DDoS-attack.";
											container app-ddos-attack-types {
												description
												"Application layer DDoS-attack types:
												Http Flood Attack, Https Flood Attack,
												DNS Flood Attack, and
												DNS Amplification Flood Attack,
												SSL DDoS Attack, and etc.";
												container http-flood-attack {
													description
													"If the application layer DDoS-attack is
													a http flood attack.";
													leaf http-flood-insp {
														type boolean;
														mandatory true;
														description
														"Additional Inspection of
														Http Flood Attack.";
													}
												}
												container https-flood-attack {
													description
													"If the application layer DDoS-attack is
													a https flood attack.";
													leaf https-flood-insp {
														type boolean;
														mandatory true;
														description
														"Additional Inspection of
														Https Flood Attack.";
													}
												}
												container dns-flood-attack {
													description
													"If the application layer DDoS-attack is
													a dns flood attack.";
													leaf dns-flood-insp {
														type boolean;
														mandatory true;
														description
														"Additional Inspection of
														DNS Flood Attack.";
													}
												}
												container dns-amp-flood-attack {
													description
													"If the application layer DDoS-attack is
													a dns amplification flood attack.";
													leaf dns-amp-flood-insp {
														type boolean;
														mandatory true;
														description
														"Additional Inspection of
														DNS Amplification Flood Attack.";
													}
												}
												container ssl-ddos-attack {
													description
													"If the application layer DDoS-attack is
													an ssl DDoS attack.";
													leaf ssl-ddos-insp {
														type boolean;
														mandatory true;
														description
														"Additional Inspection of
														SSL Flood Attack.";
													}
												}
											}
										}
									}
								}
								case single-packet-attack {
									description
									"Single Packet Attacks.";
									choice single-packet-attack-type {
										description
										"DDoS-attack types: Scanning Attack,
										Sniffing Attack, Malformed Packet Attack,
										Special Packet Attack, and etc.";
										case scan-and-sniff-attack {
											description
											"Scanning and Sniffing Attack.";
											container scan-and-sniff-attack-types {
												description
												"Scanning and sniffing attack types:
												IP Sweep attack, Port Scanning,
												and etc.";
												container ip-sweep-attack {
													description
													"If the scanning and sniffing attack is
													an ip sweep attack.";
													leaf ip-sweep-insp {
														type boolean;
														mandatory true;
														description
														"Additional Inspection of
														IP Sweep Attack.";
													}
												}
												container port-scanning-attack {
													description
													"If the scanning and sniffing attack is
													a port scanning attack.";
													leaf port-scanning-insp {
														type boolean;
														mandatory true;
														description
														"Additional Inspection of
														Port Scanning Attack.";
													}
												}
											}
										}
										case malformed-packet-attack {
											description
											"Malformed Packet Attack.";
											container malformed-packet-attack-types {
												description
												"Malformed packet attack types:
												Ping of Death Attack, Teardrop Attack,
												and etc.";
												container ping-of-death-attack {
													description
													"If the malformed packet attack is
													a ping of death attack.";
													leaf ping-of-death-insp {
														type boolean;
														mandatory true;
														description
														"Additional Inspection of
														Ping of Death Attack.";
													}
												}
												container teardrop-attack {
													description
													"If the malformed packet attack is
													a teardrop attack.";
													leaf teardrop-insp {
														type boolean;
														mandatory true;
														description
														"Additional Inspection of
														Teardrop Attack.";
													}
												}
											}
										}
										case special-packet-attack {
											description
											"special Packet Attack.";
											container special-packet-attack-types {
												description
												"Special packet attack types:
												Oversized ICMP Attack, Tracert Attack,
												and etc.";
												container oversized-icmp-attack {
													description
													"If the special packet attack is
													an oversized icmp attack.";
													leaf oversized-icmp-insp {
														type boolean;
														mandatory true;
														description
														"Additional Inspection of
														Oversize ICMP Attack.";
													}
												}
												container tracert-attack {
													description
													"If the special packet attack is
													a tracert attack.";
													leaf tracert-insp {
														type boolean;
														mandatory true;
														description
														"Additional Inspection of
														Tracrt Attack.";
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
  
  
  container cfg-content-security-conrol {
	description
	"Configuration for Content Security Control.";
	choice cfg-content-security-control-type {
		description
		"Content Security types: Antivirus, IPS, IDS,
		url-filtering, data-filtering, mail-filtering,
		file-blocking, file-isolate, pkt-capture,
		application-control, and voip-volte.";
		
		case cfg-antivirus {
			description
			"Antivirus Case.";
			list antivirus-rule {
				key antivirus-rule-id;
				description
				"Rule of Antivirus.";
				leaf antivirus-rule-id {
					type uint32;
					mandatory true;
					description
					"The ID of the rule about antivirus.";
				}
			}
		}
		case cfg-ips {
			description
			"IPS Case.";
			list ips-rule {
				key ips-rule-id;
				description
				"Rule of IPS.";
				leaf ips-rule-id {
					type uint32;
					mandatory true;
					description
					"The ID of the rule about IPS.";
				}
			}
		}
		case cfg-ids {
			description
			"IDS Case.";
			list ids-rule {
				key ids-rule-id;
				description
				"Rule of IDS.";
				leaf ids-rule-id {
					type uint32;
					mandatory true;
					description
					"The ID of the rule about IDS.";
				}
			}
		}
		case cfg-url-filter {
			description
			"URL Filter Case.";
			list url-filter-rule {
				key url-filter-rule-id;
				description
				"Rule of URL filter.";
				leaf url-filter-rule-id {
					type uint32;
					mandatory true;
					description
					"The ID of the rule about URL filter.";
				}
			}
		}
		case cfg-data-filter {
			description
			"Data Filter Case.";
			list data-filter-rule {
				key data-filter-rule-id;
				description
				"Rule of Data Filter.";
				leaf data-filter-rule-id {
					type uint32;
					mandatory true;
					description
					"The ID of the rule about data filter.";
				}
			}
		}
		case cfg-mail-filter {
			description
			"Mail Filter Case.";
			list mail-filter-rule {
				key mail-filter-rule-id;
				description
				"Rule of Mail Filter.";
				leaf mail-filter-rule-id {
					type uint32;
					mandatory true;
					description
					"The ID of the rule about mail filter.";
				}
			}
		}
		case cfg-file-blocking {
			description
			"File Blocking Case.";
			list file-blocking-rule {
				key file-blocking-rule-id;
				description
				"Rule of File Blocking.";
				leaf file-blocking-rule-id {
					type uint32;
					mandatory true;
					description
					"The ID of the rule about file blocking.";
				}
			}
		}
		case cfg-file-isolate {
			description
			"File Isolate Case.";
			list file-isolate-rule {
				key file-isolate-rule-id;
				description
				"Rule of File Isolate.";
				leaf file-isolate-rule-id {
					type uint32;
					mandatory true;
					description
					"The ID of the rule about file isolate.";
				}
			}
		}
		case cfg-pkt-capture {
			description
			"Packet Capture Case.";
			list pkt-capture-rule {
				key pkt-capture-rule-id;
				description
				"Rule of Packet Capture.";
				leaf pkt-capture-rule-id {
					type uint32;
					mandatory true;
					description
					"The ID of the rule about pacekt capture.";
				}
			}
		}
		case cfg-app-control {
			description
			"App Control Case.";
			list app-control-rule {
				key app-control-rule-id;
				description
				"Rule of App Control.";
				leaf app-control-rule-id {
					type uint32;
					mandatory true;
					description
					"The ID of the rule about app control.";
				}
			}
		}
		case cfg-voip-volte {
			description
			"VoIP/VoLTE Case.";
			list voip-volte-rule {
				key voip-volte-rule-id;
				description
				"For the VoIP/VoLTE security system, a VoIP/
				VoLTE security system can monitor each
				VoIP/VoLTE flow and manage VoIP/VoLTE
				security rules controlled by a centralized
				server for VoIP/VoLTE security service
				(called VoIP IPS). The VoIP/VoLTE security
				system controls each switch for the
				VoIP/VoLTE call flow management by
				manipulating the rules that can be added,
				deleted, or modified dynamically.";
				leaf voip-volte-rule-id {
					type uint32;
					mandatory true;
					description
					"The ID of the voip-volte-rule.
					This is the key for voip-volte-rule-list.
					This must be unique.";
				}
				container event {
					description
					"Event types: VoIP and VoLTE.";
					leaf called-voip {
						type boolean;
						mandatory true;
						description
						"If content-security-control-type is
						voip.";
					}
					leaf called-volte {
						type boolean;
						mandatory true;
						description
						"If content-security-control-type is
						volte.";
					}
				}
				container condition {
					description
					"TBD.";
					list sip-header {
						key "sip-header-uri";
						description
						"TBD.";
						leaf sip-header-uri {
							type string;
							mandatory true;
							description
							"SIP header URI.";
						}
						leaf sip-header-method {
							type string;
							mandatory true;
							description
							"SIP header method.";
						}
						leaf sip-header-expire-time {
							type string;
							units 24-our-clock;
							mandatory true;
							description
							"SIP header expire time.";
						}
						leaf sip-header-user-agent {
							type uint32;
							mandatory true;
							description
							"SIP header user agent.";
						}
					}
					list cell-region {
						key "cell-id-region";
						description
						"TBD.";
						leaf cell-id-region {
							type uint32;
							mandatory true;
							description
							"Cell region.";
						}
					}
				}
				container action {
					description
					"The flow-based NSFs realize the security
					functions by executing various Actions.";
					choice action-type {
						description
						"Action type: ingress action and
						egress action.";
						case ingress-action {
							description
							"The ingress actions consist of permit,
							deny, and mirror.";
							choice ingress-action-type {
								description
								"Ingress-action-type: permit, deny,
								and mirror.";
								case permit {
									description
									"Permit case.";
									leaf voip-volte-permit {
										type boolean;
										mandatory true;
										description
										"Packet flow is permitted.";
									}
								}
								case deny {
									description
									"Deny case.";
									leaf voip-volte-deny {
										type boolean;
										mandatory true;
										description
										"Packet flow is denied.";
									}
								}
								case voip-volte-mirror {
									description
									"Mirror case.";
									leaf mirror {
										type boolean;
										mandatory true;
										description
										"Packet flow is mirrored.";
									}
								}
							}
						}
						case egress-action {
							description
							"The engress actions consist of
							mirror and etc.";
							choice egress-action-type {
								description
								"Engress-action-type: redirection,
								and etc.";
								case redirection {
									description
									"Redirection case.";
									leaf voip_volte_redirection {
										type boolean;
										mandatory true;
										description "TBD.";
									}
								}
							}
						}
					}
				}
			}
		}
	}
 }
 

container cfg-attack-mitigation-conrol {
	description
	"Configuration for Attack Mitigation Control.";
	choice cfg-attack-mitigation-control-type {
		description
		"Attack-mitigation types: DDoS-attack and
		Single-packet attack.";
		case cfg-ddos-attack {
			description
			"A distributed-denial-of-service (DDoS) is
			where the attack source is more than one,
			often thousands of unique IP addresses.";
			choice cfg-ddos-attack-type {
				description
				"DDoS-attack types: Network Layer DDoS Attacks
				and Application Layer DDoS Attacks.";
				case cfg-network-layer-ddos-attack {
					description
					"Network layer DDoS-attack.";
					choice cfg-network-layer-ddos-attack-type {
						description
						"Network layer DDoS attack types:
						Syn Flood Attack, UDP Flood Attack,
						ICMP Flood Attack, IP Fragment Flood,
						IPv6 Related Attacks, and etc.";
						case cfg-syn-flood-attack {
							description
							"Syn Flood Attack Case.";
							list syn-flood-attack-rule {
								key syn-flood-attack-rule-id;
								description
								"Rule of Syn Flood Attack.";
								leaf syn-flood-attack-rule-id {
									type uint32;
									mandatory true;
									description
									"The ID of the rule about syn flood attack.";
								}
							}
						}
						case cfg-udp-flood-attack {
							description
							"UDP Flood Attack Case.";
							list udp-flood-attack-rule {
								key udp-flood-attack-rule-id;
								description
								"Rule of UDP Flood Attack.";
								leaf udp-flood-attack-rule-id {
									type uint32;
									mandatory true;
									description
									"The ID of the rule about udp flood attack.";
								}
							}
						}
						case cfg-icmp-flood-attack {
							description
							"ICMP Flood Attack Case.";
							list icmp-flood-attack-rule {
								key icmp-flood-attack-rule-id;
								description
								"Rule of ICMP Flood Attack.";
								leaf icmp-flood-attack-rule-id {
									type uint32;
									mandatory true;
									description
									"The ID of the rule about icmp flood attack.";
								}
							}
						}
						case cfg-ip-frag-flood-attack {
							description
							"IP Fragment Flood Attack Case.";
							list ip-frag-flood-attack-rule {
								key ip-frag-flood-attack-rule-id;
								description
								"Rule of Ip Fragment Flood Attack.";
								leaf ip-frag-flood-attack-rule-id {
									type uint32;
									mandatory true;
									description
									"The ID of the rule about
									ip fragment flood attack.";
								}
							}
						}
						case cfg-ipv6-related-attacks {
							description
							"IPv6 Related Attacks Case.";
							list ipv6-related-attacks-rule {
								key ipv6-related-attacks-rule-id;
								description
								"Rule of Ipv6 Related Attacks.";
								leaf ipv6-related-attacks-rule-id {
									type uint32;
									mandatory true;
									description
									"The ID of the rule about
									ipv6 related attacks.";
								}
							}
						}
					}
				}
				case cfg-app-layer-ddos-attack {
					description
					"Application layer DDoS-attack.";
					choice cfg-app-ddos-attack-type {
						description
						"Application layer DDoS-attack types:
						Http Flood Attack, Https Flood Attack,
						DNS Flood Attack, and
						DNS Amplification Flood Attack,
						SSL DDoS Attack, and etc.";
						case cfg-http-flood-attack {
							description
							"HTTP Flood Attack Case.";
							list http-flood-attack-rule {
								key http-flood-attack-rule-id;
								description
								"Rule of HTTP Flood Attack.";
								leaf http-flood-attack-rule-id {
									type uint32;
									mandatory true;
									description
									"The ID of the rule about
									http flood attack.";
								}
							}
						}
						case cfg-https-flood-attack {
							description
							"HTTPs Flood Attack Case.";
							list https-flood-attack-rule {
								key https-flood-attack-rule-id;
								description
								"Rule of HTTPs Flood Attack.";
								leaf https-flood-attack-rule-id {
									type uint32;
									mandatory true;
									description
									"The ID of the rule about
									https flood attack.";
								}
							}
						}
						case cfg-dns-flood-attack {
							description
							"DNS Flood Attack Case.";
							list dns-flood-attack-rule {
								key dns-flood-attack-rule-id;
								description
								"Rule of DNS Flood Attack.";
								leaf dns-flood-attack-rule-id {
									type uint32;
									mandatory true;
									description
									"The ID of the rule about
									dns flood attack.";
								}
							}
						}
						case cfg-dns-amp-flood-attack {
							description
							"DNS Amp Flood Attack Case.";
							list dns-amp-flood-attack-rule {
								key dns-amp-flood-attack-rule-id;
								description
								"Rule of DNS Amp Flood Attack.";
								leaf dns-amp-flood-attack-rule-id {
									type uint32;
									mandatory true;
									description
									"The ID of the rule about
									dns amp flood attack.";
								}
							}
						}
						case cfg-ssl-ddos-attack {
							description
							"SSL DDoS Attack Case.";
							list ssl-ddos-attack-rule {
								key ssl-ddos-attack-rule-id;
								description
								"Rule of SSL DDoS Attack.";
								leaf ssl-ddos-attack-rule-id {
									type uint32;
									mandatory true;
									description
									"The ID of the rule about
									ssl ddos attack.";
								}
							}
						}
					}
				}
			}
		}
		case cfg-single-packet-attack {
			description
			"Single Packet Attacks.";
			choice cfg-single-packet-attack-type {
				description
				"DDoS-attack types: Scanning Attack,
				Sniffing Attack, Malformed Packet Attack,
				Special Packet Attack, and etc.";
				case cfg-scan-and-sniff-attack {
					description
					"Scanning and Sniffing Attack.";
					choice cfg-scan-and-sniff-attack-type {
						description
						"Scanning and sniffing attack types:
						IP Sweep attack, Port Scanning,
						and etc.";
						case cfg-ip-sweep-attack {
							description
							"IP Sweep Attack Case.";
							list ip-sweep-attack-rule {
								key ip-sweep-attack-rule-id;
								description
								"Rule of IP Sweep Attack.";
								leaf ip-sweep-attack-rule-id {
									type uint32;
									mandatory true;
									description
									"The ID of the rule about
									ip sweep attack.";
								}
							}
						}
						case cfg-port-scanning-attack {
							description
							"Port Scanning Attack Case.";
							list port-scanning-attack-rule {
								key port-scanning-attack-rule-id;
								description
								"Rule of Port Scanning Attack.";
								leaf port-scanning-attack-rule-id {
									type uint32;
									mandatory true;
									description
									"The ID of the rule about
									port scanning attack.";
								}
							}
						}
					}
				}
				case cfg-malformed-packet-attack {
					description
					"Malformed Packet Attack.";
					choice cfg-malformed-packet-attack-type {
						description
						"Malformed packet attack types:
						Ping of Death Attack, Teardrop Attack,
						and etc.";
						case cfg-ping-of-death-attack {
							description
							"Ping of Death Attack Case.";
							list ping-of-death-attack-rule {
								key ping-of-death-attack-rule-id;
								description
								"Rule of Ping of Death Attack.";
								leaf ping-of-death-attack-rule-id {
									type uint32;
									mandatory true;
									description
									"The ID of the rule about
									ping of death attack.";
								}
							}
						}
						case cfg-teardrop-attack {
							description
							"Teardrop Attack Case.";
							list teardrop-attack-rule {
								key teardrop-attack-rule-id;
								description
								"Rule of Teardrop Attack.";
								leaf teardrop-attack-rule-id {
									type uint32;
									mandatory true;
									description
									"The ID of the rule about
									teardrop attack.";
								}
							}
						}
					}
				}
				case cfg-special-packet-attack {
					description
					"special Packet Attack.";
					choice cfg-special-packet-attack-type {
						description
						"Special packet attack types:
						Oversized ICMP Attack, Tracert Attack,
						and etc.";
						case cfg-oversized-icmp-attack {
							description
							"Oversized ICMP Attack Case.";
							list oversized-icmp-attack-rule {
								key oversized-icmp-attack-rule-id;
								description
								"Rule of Oversized ICMP Attack.";
								leaf oversized-icmp-attack-rule-id {
									type uint32;
									mandatory true;
									description
									"The ID of the rule about
									oversized icmp attack.";
								}
							}
						}
						case cfg-tracert-attack {
							description
							"Tracert Attack Case.";
							list tracert-attack-rule {
								key tracert-attack-rule-id;
								description
								"Rule of Tracert Attack.";
								leaf tracert-attack-rule-id {
									type uint32;
									mandatory true;
									description
									"The ID of the rule about
									tracert attack.";
								}
							}
						}
					}
				}




			}
		}

	}


 }
}







}
