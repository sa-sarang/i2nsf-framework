// Generated by CoffeeScript 1.12.2
(function() {
  var Expression, Yang, debug, fs, indent, parser, path,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  if (process.env.DEBUG != null) {
    debug = require('debug')('yang:schema');
  }

  fs = require('fs');

  path = require('path');

  parser = require('yang-parser');

  indent = require('indent-string');

  Expression = require('./expression');

  Yang = (function(superClass) {
    extend(Yang, superClass);

    Yang.scope = {
      extension: '0..n',
      typedef: '0..n',
      module: '0..n',
      submodule: '0..n'
    };

    Yang.clear = function() {
      if (this.module != null) {
        this.module.splice(0, this.module.length);
      }
      if (this.submodule != null) {
        return this.submodule.splice(0, this.submodule.length);
      }
    };

    Yang.parse = function(schema, opts) {
      var constraint, e, kind, offender, ref, tag;
      if (opts == null) {
        opts = {};
      }
      if (opts.compile == null) {
        opts.compile = true;
      }
      try {
        if (typeof schema === 'string') {
          schema = parser.parse(schema);
        }
      } catch (error) {
        e = error;
        if (!(e.offset > 50)) {
          e.offset = 50;
        }
        offender = schema.slice(e.offset - 50, e.offset + 50);
        offender = offender.replace(/\s\s+/g, ' ');
        throw this.error("invalid YANG syntax detected around: '" + offender + "'", offender);
      }
      if (!(schema instanceof Object)) {
        throw this.error("must pass in valid YANG schema", schema);
      }
      kind = (function() {
        switch (false) {
          case !schema.prf:
            return schema.prf + ":" + schema.kw;
          default:
            return schema.kw;
        }
      })();
      if (!!schema.arg) {
        tag = schema.arg;
      }
      schema = (new this(kind, tag))["extends"](schema.substmts.map((function(_this) {
        return function(x) {
          return _this.parse(x, false);
        };
      })(this)));
      ref = schema.scope;
      for (kind in ref) {
        constraint = ref[kind];
        if (constraint === '1' || constraint === '1..n') {
          if (!schema.hasOwnProperty(kind)) {
            throw schema.error("constraint violation for required '" + kind + "' = " + constraint);
          }
        }
      }
      if (opts.compile) {
        schema.compile();
      }
      return schema;
    };

    Yang.compose = function(data, opts) {
      var ext, i, len, ref, res;
      if (opts == null) {
        opts = {};
      }
      if (data == null) {
        throw this.error("must supply input 'data' to compose");
      }
      if (opts.kind != null) {
        ext = Yang.prototype.lookup.call(this, 'extension', opts.kind);
        if (!(ext instanceof Expression)) {
          throw this.error("unable to find requested '" + opts.kind + "' extension");
        }
        return typeof ext.compose === "function" ? ext.compose(data, opts) : void 0;
      }
      ref = this.extension;
      for (i = 0, len = ref.length; i < len; i++) {
        ext = ref[i];
        if (!(ext.compose instanceof Function)) {
          continue;
        }
        if (typeof debug === "function") {
          debug("checking data if " + ext.tag);
        }
        res = ext.compose(data, opts);
        if (res instanceof Yang) {
          return res;
        }
      }
    };

    Yang.resolve = function() {
      var dir, file, found, from, i, name, pkginfo, target;
      from = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), name = arguments[i++];
      if (typeof name !== 'string') {
        return null;
      }
      dir = from = (function() {
        switch (false) {
          case !from.length:
            return from[0];
          default:
            return path.resolve();
        }
      })();
      while ((found == null) && (dir !== '/' && dir !== '.')) {
        target = dir + "/package.json";
        if (typeof debug === "function") {
          debug("[resolve] " + name + " in " + target);
        }
        try {
          pkginfo = require(target);
          found = pkginfo.models[name];
        } catch (error) {}
        if (found != null) {
          dir = path.dirname(require.resolve(target));
          if (typeof debug === "function") {
            debug("[resolve] " + name + " check " + found + " in " + dir);
          }
          if (!path.extname(found)) {
            from = (function() {
              switch (false) {
                case !(found in pkginfo.dependencies):
                  return path.resolve(dir, 'node_modules', found);
                default:
                  return path.resolve(dir, found);
              }
            })();
            if (fs.existsSync(from)) {
              return this.resolve(from, name);
            } else {
              found = this.resolve(found, name);
            }
          }
        }
        if ((found == null) && (pkginfo != null ? pkginfo.name : void 0) === name) {
          found = path.dirname(require.resolve(target));
        }
        if (found == null) {
          dir = path.dirname(dir);
        }
      }
      file = (function() {
        switch (false) {
          case !(found == null):
            return path.resolve(from, name + ".yang");
          default:
            return path.resolve(dir, found);
        }
      })();
      if (typeof debug === "function") {
        debug("[resolve] checking if " + file + " exists");
      }
      if (fs.existsSync(file)) {
        return file;
      } else {
        return null;
      }
    };

    Yang.require = function() {
      console.warn("DEPRECATION: please use .import() instead");
      return this["import"].apply(this, arguments);
    };

    Yang["import"] = function(name, opts) {
      var basedir, dependency, e, extname, filename, ref, ref1, res;
      if (opts == null) {
        opts = {};
      }
      if (name == null) {
        return;
      }
      if (opts.basedir == null) {
        opts.basedir = '';
      }
      extname = path.extname(name);
      filename = path.resolve(opts.basedir, name);
      basedir = path.dirname(filename);
      if (!extname) {
        return (ref = Yang.prototype.match.call(this, 'module', name)) != null ? ref : this["import"](this.resolve(name), opts);
      }
      if (extname !== '.yang') {
        res = require(filename);
        if (!(res instanceof Yang)) {
          throw this.error("unable to import '" + name + "' from '" + filename + "' (not Yang expression)", res);
        }
        return res;
      }
      try {
        return this.use(this.parse(fs.readFileSync(filename, 'utf-8'), opts));
      } catch (error) {
        e = error;
        if (!(opts.compile && e.name === 'ExpressionError' && ((ref1 = e.context.kind) === 'include' || ref1 === 'import'))) {
          console.error("unable to import '" + name + "' YANG module from '" + filename + "'");
          throw e;
        }
        if (e.context.kind === 'include') {
          opts.compile = false;
        }
        dependency = this["import"](this.resolve(basedir, e.context.tag), opts);
        if (dependency == null) {
          e.message = "unable to auto-resolve '" + e.context.tag + "' dependency module";
          throw e;
        }
        if (typeof debug === "function") {
          debug("retrying import(" + name + ")");
        }
        return this["import"].apply(this, arguments);
      }
    };

    function Yang(kind, tag, extension) {
      var bindings, schema, self;
      if (!(this instanceof Yang)) {
        schema = arguments[0], bindings = arguments[1];
        if (!(schema instanceof Yang)) {
          schema = Yang.parse(schema);
        }
        return schema.bind(bindings);
      }
      if (extension == null) {
        extension = this.lookup('extension', kind);
      }
      self = Yang.__super__.constructor.call(this, kind, tag, extension);
      if (!(extension instanceof Expression)) {
        this.debug("defer processing of custom extension " + kind);
        this.once('compile:before', (function() {
          this.debug("processing deferred extension " + kind);
          extension = this.lookup('extension', kind);
          if (!(extension instanceof Yang)) {
            throw this.error("encountered unknown extension '" + kind + "'");
          }
          return this.source = extension.source, this.argument = extension.argument, extension;
        }).bind(self));
      }
      return self;
    }

    Yang.property('datakey', {
      get: function() {
        var ref;
        switch (false) {
          case !(this.parent instanceof Yang && this.parent.kind === 'module'):
            return this.parent.tag + ":" + this.tag;
          case !(this.parent instanceof Yang && this.parent.kind === 'submodule'):
            return this.parent['belongs-to'].tag + ":" + this.tag;
          default:
            return (ref = this.tag) != null ? ref : this.kind;
        }
      }
    });

    Yang.property('datapath', {
      get: function() {
        switch (false) {
          case this.parent instanceof Yang:
            return '';
          case !this.node:
            return this.parent.datapath + ("/" + this.datakey);
          default:
            return this.parent.datapath;
        }
      }
    });

    Yang.prototype.error = function(msg, context) {
      return Yang.__super__.error.call(this, "[" + this.trail + "] " + msg, context);
    };

    Yang.prototype.emit = function() {
      var args, event, ref;
      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      (ref = this.emitter).emit.apply(ref, arguments);
      if (event === 'change' && this !== this.root) {
        return this.root.emit(event, this);
      }
    };

    Yang.prototype["eval"] = function(data, opts) {
      if (opts == null) {
        opts = {};
      }
      if (opts.adaptive === true) {
        this.once('change', arguments.callee.bind(this, data, opts));
      }
      return Yang.__super__["eval"].apply(this, arguments);
    };

    Yang.prototype.merge = function(elem) {
      if (!(elem instanceof Yang)) {
        throw this.error("cannot merge invalid element into Yang", elem);
      }
      switch (elem.kind) {
        case 'type':
          return Yang.__super__.merge.call(this, elem, {
            append: true
          });
        case 'argument':
          return Yang.__super__.merge.call(this, elem, {
            replace: true
          });
        default:
          return Yang.__super__.merge.apply(this, arguments);
      }
    };

    Yang.prototype.normalizePath = function(ypath) {
      var lastPrefix, normalizeEntry, prefix2module;
      lastPrefix = null;
      prefix2module = function(root, prefix) {
        var i, j, len, len1, m, modules, ref, ref1;
        if (root.kind !== 'module') {
          return;
        }
        switch (false) {
          case root.tag !== prefix:
            return prefix;
          case root.prefix.tag !== prefix:
            return root.tag;
          default:
            ref1 = (ref = root["import"]) != null ? ref : [];
            for (i = 0, len = ref1.length; i < len; i++) {
              m = ref1[i];
              if (m.tag === prefix || m.prefix.tag === prefix) {
                return m.tag;
              }
            }
            modules = root.lookup('module');
            for (j = 0, len1 = modules.length; j < len1; j++) {
              m = modules[j];
              if (m.tag === prefix || m.prefix.tag === prefix) {
                return m.tag;
              }
            }
            return prefix;
        }
      };
      normalizeEntry = (function(_this) {
        return function(x) {
          var match, mname, prefix, ref, target;
          if (!((x != null) && !!x)) {
            return x;
          }
          match = x.match(/^(?:([._-\w]+):)?([.{[<\w][.,+_\-}():>\]\w]*)$/);
          if (match == null) {
            throw _this.error("invalid path expression '" + x + "' found in " + ypath);
          }
          ref = [match[1], match[2]], prefix = ref[0], target = ref[1];
          switch (false) {
            case !(prefix == null):
              return target;
            case prefix !== lastPrefix:
              return target;
            default:
              lastPrefix = prefix;
              mname = prefix2module(_this.root, prefix);
              return mname + ":" + target;
          }
        };
      })(this);
      ypath = ypath.replace(/\s/g, '');
      return ypath.split('/').map(normalizeEntry).join('/');
    };

    Yang.prototype.locate = function(ypath) {
      var i, j, key, kind, len, m, match, prefix, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, rest, search, selector, tag, target;
      if (ypath == null) {
        return;
      }
      this.debug("locate enter for '" + ypath + "'");
      if (typeof ypath === 'string') {
        if ((/^\//.test(ypath)) && this !== this.root) {
          return this.root.locate(ypath);
        }
        ref = this.normalizePath(ypath).split('/').filter(function(e) {
          return !!e;
        }), key = ref[0], rest = 2 <= ref.length ? slice.call(ref, 1) : [];
      } else {
        key = ypath[0], rest = 2 <= ypath.length ? slice.call(ypath, 1) : [];
      }
      if (!((key != null) && key !== '.')) {
        return this;
      }
      if (key === '..') {
        return (ref1 = this.parent) != null ? ref1.locate(rest) : void 0;
      }
      match = key.match(/^(?:([._-\w]+):)?([.{[<\w][.,+_\-}():>\]\w]*)$/);
      ref2 = [match[1], match[2]], prefix = ref2[0], target = ref2[1];
      if ((prefix != null) && this === this.root) {
        search = [target].concat(rest);
        if ((this.tag === prefix) || (this.lookup('prefix', prefix))) {
          this.debug("locate (local) '/" + prefix + ":" + (search.join('/')) + "'");
          return Yang.__super__.locate.call(this, search);
        }
        ref4 = (ref3 = this["import"]) != null ? ref3 : [];
        for (i = 0, len = ref4.length; i < len; i++) {
          m = ref4[i];
          if (!(m.tag === prefix || m.prefix.tag === prefix)) {
            continue;
          }
          this.debug("locate (external) '/" + prefix + ":" + (search.join('/')) + "'");
          return m.module.locate(search);
        }
        m = this.lookup('module', prefix);
        return m != null ? m.locate(search) : void 0;
      }
      switch (false) {
        case !/^{.+}$/.test(target):
          kind = 'grouping';
          tag = target.replace(/^{(.+)}$/, '$1');
          break;
        case !/^\[.+\]$/.test(target):
          kind = 'feature';
          tag = target.replace(/^\[(.+)\]$/, '$1');
          break;
        case !/^[^(]+\([^)]*\)$/.test(target):
          target = target.match(/^([^(]+)\((.*)\)$/);
          ref5 = [target[1], target[2]], kind = ref5[0], tag = ref5[1];
          if (!tag) {
            tag = void 0;
          }
          break;
        case !/^\<.+\>$/.test(target):
          target = target.replace(/^\<(.+)\>$/, '$1');
          ref6 = target.split(':'), kind = 2 <= ref6.length ? slice.call(ref6, 0, j = ref6.length - 1) : (j = 0, []), tag = ref6[j++];
          ref7 = tag.split('='), tag = ref7[0], selector = ref7[1];
          if (kind != null ? kind.length : void 0) {
            kind = kind[0];
          }
          break;
        default:
          return Yang.__super__.locate.call(this, [key].concat(rest));
      }
      match = this.match(kind, tag);
      switch (false) {
        case rest.length !== 0:
          return match;
        default:
          return match != null ? match.locate(rest) : void 0;
      }
    };

    Yang.prototype.match = function(kind, tag) {
      var arg, ctx, i, imports, j, len, m, prefix, ref, ref1, ref2, ref3, res;
      if (!((kind != null) && (tag != null) && typeof tag === 'string')) {
        return Yang.__super__.match.apply(this, arguments);
      }
      res = Yang.__super__.match.apply(this, arguments);
      if (res != null) {
        return res;
      }
      ref = tag.split(':'), prefix = 2 <= ref.length ? slice.call(ref, 0, i = ref.length - 1) : (i = 0, []), arg = ref[i++];
      if (!prefix.length) {
        return;
      }
      if (typeof debug === "function") {
        debug("[match] with " + kind + " " + tag);
      }
      prefix = prefix[0];
      if (typeof debug === "function") {
        debug("[match] check if current module's prefix");
      }
      if (this.root.tag === prefix || ((ref1 = this.root.prefix) != null ? ref1.tag : void 0) === prefix) {
        return this.root.match(kind, arg);
      }
      if (typeof debug === "function") {
        debug("[match] checking if submodule's parent");
      }
      ctx = this.lookup('belongs-to');
      if ((ctx != null ? ctx.prefix.tag : void 0) === prefix) {
        return ctx.module.match(kind, arg);
      }
      if (typeof debug === "function") {
        debug("[match] check if one of current module's imports");
      }
      imports = (ref2 = (ref3 = this.root) != null ? ref3["import"] : void 0) != null ? ref2 : [];
      for (j = 0, len = imports.length; j < len; j++) {
        m = imports[j];
        if (!(m.prefix.tag === prefix)) {
          continue;
        }
        if (typeof debug === "function") {
          debug(m.module);
        }
        return m.module.match(kind, arg);
      }
    };

    Yang.prototype.toString = function(opts) {
      var s, sub;
      if (opts == null) {
        opts = {
          space: 2
        };
      }
      s = this.kind;
      if (this.source.argument != null) {
        s += ' ' + (function() {
          switch (this.source.argument) {
            case 'value':
              return "'" + this.tag + "'";
            case 'text':
              return "\n" + (indent('"' + this.tag + '"', ' ', opts.space));
            default:
              return this.tag;
          }
        }).call(this);
      }
      sub = this.elements.filter((function(_this) {
        return function(x) {
          return x.parent === _this;
        };
      })(this)).map(function(x) {
        return x.toString(opts);
      }).join("\n");
      if (!!sub) {
        s += " {\n" + (indent(sub, ' ', opts.space)) + "\n}";
      } else {
        s += ';';
      }
      return s;
    };

    Yang.prototype.valueOf = function() {
      switch (this.source.argument) {
        case 'value':
        case 'text':
          return this.tag.valueOf();
        default:
          return this;
      }
    };

    return Yang;

  })(Expression);

  module.exports = Yang;

}).call(this);
