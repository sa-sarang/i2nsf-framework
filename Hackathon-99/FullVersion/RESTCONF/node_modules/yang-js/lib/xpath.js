// Generated by CoffeeScript 1.12.2
(function() {
  var Expression, Filter, Operator, XPath, debug, exports,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  if (process.env.DEBUG != null) {
    debug = require('debug')('yang:xpath');
  }

  Expression = require('./expression');

  Operator = require('../ext/parser').Parser;

  Filter = (function(superClass) {
    extend(Filter, superClass);

    function Filter(pattern1) {
      var e, expr;
      this.pattern = pattern1 != null ? pattern1 : '';
      if (!((Number.isNaN(Number(this.pattern))) || ((Number(this.pattern)) % 1) !== 0)) {
        expr = Number(this.pattern);
      } else {
        try {
          expr = Operator.parse(this.pattern);
        } catch (error) {
          e = error;
          console.error("unable to parse '" + this.pattern + "'");
          throw e;
        }
      }
      if (!expr) {
        throw this.error("invalid predicate filter: [" + expr + "]");
      }
      Filter.__super__.constructor.call(this, 'filter', expr, {
        argument: 'predicate',
        scope: {},
        transform: function(data) {
          var elem, i, key, len, vars;
          if (!(data instanceof Array)) {
            return data;
          }
          if (!(data.length > 0)) {
            return data;
          }
          if (typeof debug === "function") {
            debug("filter: " + this.tag);
          }
          if (typeof this.tag === 'number') {
            return [data[this.tag - 1]];
          }
          vars = this.tag.variables();
          if (indexOf.call(vars, 'key') >= 0) {
            key = this.pattern.replace(/key\('(.+)'\)/, '$1');
            for (i = 0, len = data.length; i < len; i++) {
              elem = data[i];
              if (elem['@key'] === key) {
                return [elem];
              }
            }
            return [];
          }
          data = data.filter((function(_this) {
            return function(elem) {
              expr = vars.reduce((function(a, b) {
                a[b] = (function() {
                  switch (b) {
                    case 'current':
                      return function() {
                        return elem;
                      };
                    case 'false':
                      return function() {
                        return false;
                      };
                    case 'true':
                      return function() {
                        return true;
                      };
                    default:
                      return elem[b];
                  }
                })();
                return a;
              }), {});
              try {
                return _this.tag.evaluate(expr);
              } catch (error) {
                e = error;
                if (typeof debug === "function") {
                  debug(e);
                }
                return false;
              }
            };
          })(this));
          return data;
        }
      });
    }

    Filter.prototype.clone = function() {
      return new this.constructor(this.pattern);
    };

    Filter.prototype.toString = function() {
      return this.pattern;
    };

    return Filter;

  })(Expression);

  XPath = (function(superClass) {
    extend(XPath, superClass);

    function XPath(pattern, schema) {
      var e, elements, match, predicates, ref, target;
      if (typeof pattern !== 'string') {
        throw this.error("must pass in 'pattern' as valid string");
      }
      if (typeof debug === "function") {
        debug("[" + pattern + "] constructing...");
      }
      elements = pattern.match(/([^\/^\[]*(?:\[.+?\])*)/g);
      if (elements == null) {
        elements = [];
      }
      elements = elements.filter(function(x) {
        return !!x;
      });
      if (/^\//.test(pattern)) {
        target = '/';
        if (schema instanceof Expression) {
          schema = schema.root;
        }
        predicates = [];
      } else {
        if (!(elements.length > 0)) {
          throw this.error("unable to process '" + pattern + "' (please check your input)");
        }
        ref = elements.shift().split(/\[\s*(.+?)\s*\]/), target = ref[0], predicates = 2 <= ref.length ? slice.call(ref, 1) : [];
        if (target == null) {
          throw this.error("unable to process '" + pattern + "' (missing axis)");
        }
        predicates = predicates.filter(function(x) {
          return !!x;
        });
        if (schema instanceof Expression) {
          if (typeof debug === "function") {
            debug("[" + pattern + "] with " + schema.kind + "(" + schema.tag + ")");
          }
          try {
            match = schema.locate(target);
          } catch (error) {
            e = error;
            console.warn(e);
          }
          if (match == null) {
            switch (schema.kind) {
              case 'list':
                predicates.unshift((function() {
                  switch (false) {
                    case schema.key == null:
                      return "key('" + target + "')";
                    default:
                      return target;
                  }
                })());
                target = '.';
                break;
              case 'anydata':
                schema = void 0;
                break;
              default:
                throw this.error("unable to locate '" + target + "' inside schema: " + schema.trail);
            }
          } else {
            schema = match;
            if (!/^\./.test(target)) {
              target = schema.datakey;
            }
          }
        }
      }
      XPath.__super__.constructor.call(this, 'xpath', target, {
        argument: 'node',
        scope: {
          filter: '0..n',
          xpath: '0..1'
        },
        transform: function(data) {
          return this.process(data);
        }
      });
      if (schema instanceof Expression) {
        Object.defineProperty(this, 'schema', {
          value: schema
        });
      }
      if (predicates.length > 0) {
        this["extends"].apply(this, predicates.map(function(x) {
          return new Filter(x);
        }));
      }
      if (elements.length > 0) {
        this["extends"](elements.join('/'));
      }
      if (typeof debug === "function") {
        debug("[" + pattern + "] construction complete");
      }
    }

    XPath.prototype.clone = function() {
      var ref, schema;
      if (typeof debug === "function") {
        debug("[" + this.tag + "] cloning...");
      }
      schema = this.tag === '/' ? this.schema : (ref = this.parent) != null ? ref.schema : void 0;
      return (new this.constructor(this.tag, schema))["extends"](this.elements.map(function(x) {
        return x.clone();
      }));
    };

    XPath.prototype.merge = function(elem) {
      elem = (function() {
        switch (false) {
          case !(elem instanceof Expression):
            return elem;
          default:
            return new XPath(elem, this.schema);
        }
      }).call(this);
      if (elem.tag === '.') {
        if (typeof debug === "function") {
          debug("[merge] absorbing sub-XPATH into '" + this.tag + "'");
        }
        this["extends"](elem.filter, elem.xpath);
        return this;
      } else {
        return XPath.__super__.merge.call(this, elem);
      }
    };

    XPath.prototype.process = function(data) {
      var expr, i, len, props, ref, ref1, ref2, ref3;
      if (typeof debug === "function") {
        debug("[" + this.tag + "] process using schema from " + ((ref = this.schema) != null ? ref.kind : void 0) + ":" + ((ref1 = this.schema) != null ? ref1.tag : void 0));
      }
      if (typeof debug === "function") {
        debug(data);
      }
      if (!(data instanceof Object)) {
        return [];
      }
      props = [];
      if (!(data instanceof Array)) {
        data = [data];
      }
      data = data.reduce(((function(_this) {
        return function(a, b) {
          if (!(b instanceof Array)) {
            b = [b];
          }
          return a.concat.apply(a, b.map(function(elem) {
            return _this.match(elem, props);
          }));
        };
      })(this)), []);
      data = data.filter(function(e) {
        return e != null;
      });
      if (typeof debug === "function") {
        debug("[" + this.tag + "] found " + data.length + " matching nodes");
      }
      if (typeof debug === "function") {
        debug(data);
      }
      if (this.filter != null) {
        ref2 = this.filter;
        for (i = 0, len = ref2.length; i < len; i++) {
          expr = ref2[i];
          if (!data.length) {
            break;
          }
          data = expr["eval"](data);
        }
      }
      if (this.xpath != null) {
        if (typeof debug === "function") {
          debug("apply additional XPATH expressions");
        }
        if ((this.xpath != null) && data.length) {
          data = this.xpath["eval"](data);
        }
      } else {
        if (typeof debug === "function") {
          debug("end of XPATH, collecting props");
        }
        if (this.filter != null) {
          props = (data.map(function(x) {
            return x.__;
          })).filter(function(x) {
            return x != null;
          });
        }
        if (typeof debug === "function") {
          debug(props);
        }
        Object.defineProperty(data, 'props', {
          value: props
        });
      }
      if (typeof debug === "function") {
        debug("[" + this.tag + "] returning " + data.length + " data with " + ((ref3 = data.props) != null ? ref3.length : void 0) + " properties");
      }
      return data;
    };

    XPath.prototype.match = function(item, props) {
      var k, key, res, v;
      if (props == null) {
        props = [];
      }
      key = (function() {
        switch (false) {
          case this.tag !== '/':
            return '.';
          default:
            return this.tag;
        }
      }).call(this);
      if (!(item instanceof Object)) {
        return;
      }
      res = (function() {
        var ref, results;
        switch (false) {
          case key !== '.':
            return item;
          case key !== '..':
            switch (false) {
              case !((item.__ != null) && (item.__.key != null)):
                return item.__.parent.container;
              case item.__ == null:
                return item.__.container;
            }
            break;
          case key !== '*':
            results = [];
            for (k in item) {
              if (!hasProp.call(item, k)) continue;
              v = item[k];
              results.push(v);
            }
            return results;
          case !item.hasOwnProperty(key):
            return item[key];
          case !(this.schema instanceof Expression):
            key = this.schema.datakey;
            return item[key];
          case item.__ == null:
            key = (ref = item.__.schema) != null ? ref.datakey : void 0;
            if (key != null) {
              return item[key];
            }
        }
      }).call(this);
      switch (false) {
        case key !== '*':
          if (res != null) {
            res.forEach(function(x) {
              if (x.__ != null) {
                return props.push(x.__);
              }
            });
          }
          break;
        case (res != null ? res.__ : void 0) == null:
          props.push(res.__);
          break;
        case item.__props__ == null:
          if (key in item.__props__) {
            props.push(item.__props__[key]);
          }
      }
      return res;
    };

    XPath.prototype.locate = function(pattern) {
      try {
        if (!(pattern instanceof XPath)) {
          pattern = new XPath(pattern, this.schema);
        }
        if (this.tag !== pattern.tag) {
          return;
        }
        if (!((pattern.filter == null) || ("" + this.filter) === ("" + pattern.filter))) {
          return;
        }
        switch (false) {
          case !((this.xpath != null) && (pattern.xpath != null)):
            return this.xpath.locate(pattern.xpath);
          case pattern.xpath == null:
            return void 0;
          default:
            return this;
        }
      } catch (error) {}
    };

    XPath.prototype.trim = function(pattern) {
      var match;
      match = this.locate(pattern);
      if (match != null) {
        delete match.xpath;
      }
      return this;
    };

    XPath.prototype.append = function(pattern) {
      var end;
      end = this;
      while (end.xpath != null) {
        end = end.xpath;
      }
      if (typeof debug === "function") {
        debug("[" + this.tag + "] appending " + pattern + " to " + end.tag);
      }
      end.merge(pattern);
      return this;
    };

    XPath.prototype.contains = function() {
      var i, len, pattern, patterns;
      patterns = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      for (i = 0, len = patterns.length; i < len; i++) {
        pattern = patterns[i];
        if (this.locate(pattern) != null) {
          return pattern;
        }
      }
    };

    XPath.prototype.toString = function() {
      var filter, i, len, ref, s;
      s = this.tag === '/' ? '' : this.tag;
      if (this.filter != null) {
        ref = this.filter;
        for (i = 0, len = ref.length; i < len; i++) {
          filter = ref[i];
          s += "[" + filter + "]";
        }
      }
      if (this.xpath != null) {
        s += "/" + this.xpath;
      }
      if (!s) {
        s = this.tag;
      }
      return s;
    };

    return XPath;

  })(Expression);

  exports = module.exports = XPath;

  exports.Filter = Filter;

  exports.parse = function(pattern, schema) {
    return new XPath(pattern, schema);
  };

}).call(this);
