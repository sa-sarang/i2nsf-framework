// Generated by CoffeeScript 1.12.2
(function() {
  var Integer, Typedef,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Typedef = require('../typedef');

  Integer = (function(superClass) {
    extend(Integer, superClass);

    function Integer(name, range) {
      Integer.__super__.constructor.call(this, name, {
        construct: function(value) {
          var ranges, ref, tests;
          if ((Number.isNaN(Number(value))) || ((Number(value)) % 1) !== 0) {
            throw new Error("[" + this.tag + "] unable to convert '" + value + "'");
          }
          if (typeof value === 'string' && !value) {
            throw new Error("[" + this.tag + "] unable to convert '" + value + "'");
          }
          value = Number(value);
          ranges = (ref = this.range) != null ? ref.tag.split('|') : void 0;
          if (ranges == null) {
            ranges = [range];
          }
          tests = ranges.map(function(e) {
            var max, min, ref1;
            ref1 = e.split(/\s*\.\.\s*/), min = ref1[0], max = ref1[1];
            min = Number(min);
            max = (function() {
              switch (false) {
                case max !== 'max':
                  return null;
                default:
                  return Number(max);
              }
            })();
            return function(v) {
              return ((min == null) || v >= min) && ((max == null) || v <= max);
            };
          });
          if (!((tests == null) || tests.some(function(test) {
            return typeof test === "function" ? test(value) : void 0;
          }))) {
            throw new Error("[" + this.tag + "] range violation for '" + value + "' on " + ranges);
          }
          return value;
        }
      });
    }

    return Integer;

  })(Typedef);

  module.exports = [
    new Typedef('boolean', {
      construct: function(value) {
        switch (false) {
          case typeof value !== 'string':
            if (value !== 'true' && value !== 'false') {
              throw new Error("[" + this.tag + "] " + value + " must be 'true' or 'false'");
            }
            return value === 'true';
          case typeof value !== 'boolean':
            return value;
          default:
            throw new Error("[" + this.tag + "] unable to convert '" + value + "'");
        }
      }
    }), new Typedef('empty', {
      construct: function(value) {
        this.debug("convert");
        this.debug(value);
        if (value !== null) {
          throw new Error("[" + this.tag + "] cannot contain value other than null");
        }
        return null;
      }
    }), new Typedef('binary', {
      construct: function(value) {
        if (!(value instanceof Buffer)) {
          throw new Error("[" + this.tag + "] unable to convert '" + value + "'");
        }
        return value;
      }
    }), new Integer('int8', '-128..127'), new Integer('int16', '-32768..32767'), new Integer('int32', '-2147483648..2147483647'), new Integer('int64', '-9223372036854775808..9223372036854775807'), new Integer('uint8', '0..255'), new Integer('uint16', '0..65535'), new Integer('uint32', '0..4294967295'), new Integer('uint64', '0..18446744073709551615'), new Typedef('decimal64', {
      construct: function(value) {
        if (Number.isNaN(Number(value))) {
          throw new Error("[" + this.tag + "] unable to convert '" + value + "'");
        }
        if (typeof value === 'string' && !value) {
          throw new Error("[" + this.tag + "] unable to convert '" + value + "'");
        }
        switch (false) {
          case typeof value !== 'string':
            return Number(value);
          case typeof value !== 'number':
            return value;
          default:
            throw new Error("[" + this.tag + "] type violation for " + value);
        }
      }
    }), new Typedef('string', {
      construct: function(value) {
        var lengths, patterns, ref, ref1, tests, type;
        patterns = (ref = this.pattern) != null ? ref.map(function(x) {
          return x.tag;
        }) : void 0;
        lengths = (ref1 = this.length) != null ? ref1.tag.split('|') : void 0;
        tests = lengths != null ? lengths.map(function(e) {
          var max, min, ref2;
          ref2 = e.split(/\s*\.\.\s*/), min = ref2[0], max = ref2[1];
          min = Number(min);
          max = (function() {
            switch (false) {
              case !(max == null):
                return min;
              case max !== 'max':
                return null;
              default:
                return Number(max);
            }
          })();
          return function(v) {
            return ((min == null) || v.length >= min) && ((max == null) || v.length <= max);
          };
        }) : void 0;
        type = typeof value;
        value = String(value);
        if (type === 'object' && /^\[object/.test(value)) {
          throw new Error("[" + this.tag + "] unable to convert '" + value + "' into string");
        }
        if (!((tests == null) || tests.some(function(test) {
          return typeof test === "function" ? test(value) : void 0;
        }))) {
          throw new Error("[" + this.tag + "] length violation for '" + value + "' on " + lengths);
        }
        if (!((patterns == null) || patterns.every(function(regex) {
          return regex.test(value);
        }))) {
          throw new Error("[" + this.tag + "] pattern violation for '" + value + "'");
        }
        return value;
      }
    }), new Typedef('union', {
      construct: function(value) {
        var j, len, ref, type;
        if (this.type == null) {
          throw new Error("[" + this.tag + "] must contain one or more type definitions");
        }
        ref = this.type;
        for (j = 0, len = ref.length; j < len; j++) {
          type = ref[j];
          try {
            return type.convert(value);
          } catch (error) {
            continue;
          }
        }
        throw new Error("[" + this.tag + "] unable to find matching type for '" + value + "' within: " + this.type);
      }
    }), new Typedef('enumeration', {
      construct: function(value) {
        var i, j, len, ref, ref1;
        if (!(((ref = this["enum"]) != null ? ref.length : void 0) > 0)) {
          throw new Error("[" + this.tag + "] must have one or more 'enum' definitions");
        }
        ref1 = this["enum"];
        for (j = 0, len = ref1.length; j < len; j++) {
          i = ref1[j];
          if (value === i.tag) {
            return i.tag;
          }
          if (value === i.value.tag) {
            return i.tag;
          }
          if (("" + value) === i.value.tag) {
            return i.tag;
          }
        }
        throw new Error("[" + this.tag + "] type violation for '" + value + "' on " + (this["enum"].map(function(x) {
          return x.tag;
        })));
      }
    }), new Typedef('identityref', {
      construct: function(value, ctx) {
        var dep, imports, j, k, len, len1, m, match, modules, ref;
        if (!((this.base != null) && typeof this.base.tag === 'string')) {
          throw new Error("[" + this.tag + "] must reference 'base' identity");
        }
        return value;
        match = this.lookup('identity', value);
        if (match == null) {
          imports = (ref = this.lookup('import')) != null ? ref : [];
          for (j = 0, len = imports.length; j < len; j++) {
            dep = imports[j];
            match = dep.module.lookup('identity', value);
            if (match != null) {
              break;
            }
          }
          if (match == null) {
            modules = this.lookup('module');
            this.debug("fallback searching all modules " + (modules.map(function(x) {
              return x.tag;
            })));
            for (k = 0, len1 = modules.length; k < len1; k++) {
              m = modules[k];
              match = m.lookup('identity', value);
              if (match != null) {
                break;
              }
            }
          }
        }
        if ((match != null ? match.base : void 0) != null) {
          match = match.base.state.identity;
        }
        this.debug("base: " + this.base + " match: " + match + " value: " + value);
        if (!((match != null) && this.base.state.identity === match)) {
          ctx["throw"]("[" + this.tag + "] identityref is invalid for '" + value + "'");
        }
        return value;
      }
    }), new Typedef('instance-identifier', {
      construct: function(value, ctx) {
        var e, err, prop, ref;
        this.debug("processing instance-identifier with " + value);
        try {
          prop = ctx["in"](value);
          if (prop.config !== ((ref = this['require-instance']) != null ? ref.tag : void 0)) {
            ctx["throw"]("not a configuration node");
          }
        } catch (error) {
          e = error;
          err = new Error("[" + this.tag + "] " + ctx.name + " is invalid for '" + value + "' (not found in " + value + ")");
          err['error-tag'] = 'data-missing';
          err['error-app-tag'] = 'instance-required';
          err['err-path'] = value;
          if (!ctx.state.suppress) {
            ctx["throw"](err);
          }
          return err;
        }
        return value;
      }
    }), new Typedef('leafref', {
      construct: function(value, ctx) {
        var err, res, valid;
        if (this.path == null) {
          throw new Error("[" + this.tag + "] must contain 'path' statement");
        }
        this.debug("processing leafref with " + this.path.tag);
        res = ctx.get(this.path.tag);
        this.debug("got back " + res);
        valid = (function() {
          switch (false) {
            case !(res instanceof Array):
              return indexOf.call(res, value) >= 0;
            default:
              return res === value;
          }
        })();
        if (valid !== true) {
          this.debug("invalid leafref '" + value + "' detected for " + this.path.tag);
          this.debug(ctx.state);
          err = new Error("[" + this.tag + "] " + ctx.name + " is invalid for '" + value + "' (not found in " + this.path.tag + ")");
          err['error-tag'] = 'data-missing';
          err['error-app-tag'] = 'instance-required';
          err['err-path'] = this.path.tag;
          if (!ctx.state.suppress) {
            ctx["throw"](err);
          }
          return err;
        }
        return value;
      }
    })
  ];

}).call(this);
