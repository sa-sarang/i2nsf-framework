// Generated by CoffeeScript 1.12.2
(function() {
  var ARGUMENT_NAMES, Extension, Model, STRIP_COMMENTS, XPath, Yang, assert,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Yang = require('../yang');

  Model = require('../model');

  XPath = require('../xpath');

  Extension = require('../extension');

  assert = require('assert');

  STRIP_COMMENTS = /(\/\/.*$)|(\/\*[\s\S]*?\*\/)|(\s*=[^,\)]*(('(?:\\'|[^'\r\n])*')|("(?:\\"|[^"\r\n])*"))|(\s*=[^,\)]*))/mg;

  ARGUMENT_NAMES = /([^\s,]+)/g;

  module.exports = [
    new Extension('action', {
      argument: 'name',
      scope: {
        description: '0..1',
        grouping: '0..n',
        'if-feature': '0..n',
        input: '0..1',
        output: '0..1',
        reference: '0..1',
        status: '0..1',
        typedef: '0..n'
      },
      predicate: function(data) {
        if (data == null) {
          data = function() {};
        }
        return assert(data instanceof Function, "data must contain a valid instanceof Function");
      },
      transform: function(data) {
        var expr, i, len, ref1, ref2;
        if (data == null) {
          data = (ref1 = this.binding) != null ? ref1 : (function(_this) {
            return function() {
              throw _this.error("missing function binding");
            };
          })(this);
        }
        if (!(data instanceof Function)) {
          this.debug(data);
          throw this.error("expected a function but got a '" + (typeof data) + "'");
        }
        ref2 = this.exprs;
        for (i = 0, len = ref2.length; i < len; i++) {
          expr = ref2[i];
          data = expr["eval"](data);
        }
        return data;
      },
      construct: function(data) {
        if (data == null) {
          data = {};
        }
        return (new Model.Property(this.tag, this)).join(data);
      },
      compose: function(data, opts) {
        var expr, i, kind, len, match, matches, possibilities, ref1;
        if (opts == null) {
          opts = {};
        }
        if (!(data instanceof Function)) {
          return;
        }
        if (Object.keys(data).length !== 0) {
          return;
        }
        if (!((data.prototype == null) || Object.keys(data.prototype).length === 0)) {
          return;
        }
        possibilities = (function() {
          var ref1, results;
          ref1 = this.scope;
          results = [];
          for (kind in ref1) {
            if (!hasProp.call(ref1, kind)) continue;
            results.push(this.lookup('extension', kind));
          }
          return results;
        }).call(this);
        matches = [];
        for (i = 0, len = possibilities.length; i < len; i++) {
          expr = possibilities[i];
          if (!(expr != null)) {
            continue;
          }
          match = typeof expr.compose === "function" ? expr.compose(data) : void 0;
          if (match != null) {
            matches.push(match);
          }
        }
        return (ref1 = new Yang(this.tag, opts.tag, this))["extends"].apply(ref1, matches);
      }
    }), new Extension('anydata', {
      argument: 'name',
      scope: {
        config: '0..1',
        description: '0..1',
        'if-feature': '0..n',
        mandatory: '0..1',
        must: '0..n',
        reference: '0..1',
        status: '0..1',
        when: '0..1'
      },
      construct: function() {
        return this.apply.apply(this, arguments);
      }
    }), new Extension('argument', {
      argument: 'arg-type',
      scope: {
        'yin-element': '0..1'
      }
    }), new Extension('augment', {
      argument: 'target-node',
      scope: {
        action: '0..n',
        anydata: '0..n',
        anyxml: '0..n',
        "case": '0..n',
        choice: '0..n',
        container: '0..n',
        description: '0..1',
        'if-feature': '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        notification: '0..n',
        reference: '0..1',
        status: '0..1',
        uses: '0..n',
        when: '0..1'
      },
      resolve: function() {
        var target;
        target = (function() {
          switch (this.parent.kind) {
            case 'module':
              if (!/^\//.test(this.tag)) {
                throw this.error("'" + this.tag + "' must be absolute-schema-path to augment within module statement");
              }
              return this.locate(this.tag);
            case 'uses':
              if (/^\//.test(this.tag)) {
                throw this.error("'" + this.tag + "' must be relative-schema-path to augment within uses statement");
              }
              return this.parent.state.grouping.locate(this.tag);
          }
        }).call(this);
        if (target == null) {
          console.warn(this.error("unable to locate '" + this.tag + "'"));
          return;
        }
        if (this.when == null) {
          return this.once('compile:after', (function(_this) {
            return function() {
              var from;
              _this.debug("augmenting '" + target.kind + ":" + target.tag + "'");
              if (_this.parent.kind === 'module' && target.root !== _this.root) {
                from = _this.root.tag;
              }
              return target["extends"](_this.nodes.map(function(x) {
                var copy;
                copy = x.clone();
                if (from != null) {
                  copy.tag = from + ":" + x.tag;
                }
                return copy;
              }));
            };
          })(this));
        } else {
          return target.on('apply:after', (function(_this) {
            return function(data) {
              var expr, i, len, ref1, results;
              if (data != null) {
                ref1 = _this.exprs;
                results = [];
                for (i = 0, len = ref1.length; i < len; i++) {
                  expr = ref1[i];
                  results.push(data = expr.apply(data));
                }
                return results;
              }
            };
          })(this));
        }
      }
    }), new Extension('base', {
      argument: 'name',
      resolve: function() {
        var ref;
        ref = this.state.identity = this.lookup('identity', this.tag);
        if (ref == null) {
          throw this.error("unable to resolve '" + this.tag + "' identity");
        }
      }
    }), new Extension('belongs-to', {
      argument: 'module-name',
      scope: {
        prefix: '1'
      },
      resolve: function() {
        this.module = this.lookup('module', this.tag);
        if (this.module == null) {
          throw this.error("unable to resolve '" + this.tag + "' module");
        }
      }
    }), new Extension('bit', {
      argument: 'name',
      scope: {
        description: '0..1',
        'if-feature': '0..n',
        reference: '0..1',
        status: '0..1',
        position: '0..1'
      }
    }), new Extension('case', {
      argument: 'name',
      scope: {
        anyxml: '0..n',
        choice: '0..n',
        container: '0..n',
        description: '0..1',
        'if-feature': '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        reference: '0..1',
        status: '0..1',
        uses: '0..n',
        when: '0..1'
      },
      resolve: function() {
        return this.once('compile:after', (function(_this) {
          return function() {
            if (!(_this.nodes.length > 0)) {
              throw _this.error("cannot have an empty case statement");
            }
          };
        })(this));
      },
      transform: function(data, ctx) {
        var expr, i, keys, len, ref1;
        if (!(data instanceof Object)) {
          return data;
        }
        keys = Object.keys(data);
        if (!(this.nodes.some(function(x) {
          var ref1;
          return ref1 = x.tag, indexOf.call(keys, ref1) >= 0;
        }))) {
          return data;
        }
        ref1 = this.exprs;
        for (i = 0, len = ref1.length; i < len; i++) {
          expr = ref1[i];
          data = expr["eval"](data, ctx);
        }
        return data;
      },
      predicate: function(data) {
        assert(data instanceof Object, "data must contain Object data");
        return assert(this.nodes.some(function(x) {
          return x.tag in data;
        }), "data must contain a matching element");
      }
    }), new Extension('choice', {
      argument: 'condition',
      scope: {
        anyxml: '0..n',
        "case": '0..n',
        config: '0..1',
        container: '0..n',
        "default": '0..1',
        description: '0..1',
        'if-feature': '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        mandatory: '0..1',
        reference: '0..1',
        status: '0..1',
        when: '0..1'
      },
      resolve: function() {
        var ref1, ref2;
        if (this.nodes.length > 0 && this.nodes.length !== ((ref1 = this["case"]) != null ? ref1.length : void 0)) {
          throw this.error("cannot contain more than one non-case data node statement");
        }
        if (((ref2 = this.mandatory) != null ? ref2.tag : void 0) === 'true' && (this["default"] != null)) {
          throw this.error("cannot define 'default' when 'mandatory' is true");
        }
        if ((this["default"] != null) && ((this.match('case', this["default"].tag)) == null)) {
          throw this.error("cannot specify default '" + this["default"].tag + "' without a corresponding case");
        }
      },
      transform: function(data, ctx) {
        var attr, block, defcase, expr, i, j, l, len, len1, len2, len3, match, n, ref1, ref2, ref3, ref4;
        if (this["case"] == null) {
          ref1 = this.exprs;
          for (i = 0, len = ref1.length; i < len; i++) {
            expr = ref1[i];
            data = expr["eval"](data, ctx);
          }
          return data;
        }
        ref2 = this["case"];
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          block = ref2[j];
          this.debug("checking if case " + block.tag + "...");
          try {
            data = block["eval"](data, ctx);
            match = block.tag;
            break;
          } catch (error) {}
        }
        switch (false) {
          case !((match == null) && (this["default"] != null)):
            this.debug("choice fallback to default: " + this["default"].tag);
            match = this["default"].tag;
            defcase = this.match('case', this["default"].tag);
            ref3 = defcase.exprs;
            for (l = 0, len2 = ref3.length; l < len2; l++) {
              expr = ref3[l];
              data = expr["eval"](data, ctx);
            }
            break;
          case !((match == null) && (this.mandatory != null)):
            throw this.error("no matching choice found (mandatory)");
        }
        ref4 = this.attrs;
        for (n = 0, len3 = ref4.length; n < len3; n++) {
          attr = ref4[n];
          if (attr.kind !== 'case') {
            data = attr["eval"](data, ctx);
          }
        }
        Object.defineProperty(data, '@choice', {
          value: match
        });
        return data;
      },
      construct: function() {
        return this.apply.apply(this, arguments);
      }
    }), new Extension('config', {
      argument: 'value',
      resolve: function() {
        this.tag = this.tag === true || this.tag === 'true';
        return this.parent.once('compile:after', (function(_this) {
          return function() {
            return _this.parent.nodes.map(function(node) {
              try {
                return node.update(_this);
              } catch (error) {}
            });
          };
        })(this));
      }
    }), new Extension('contact', {
      argument: 'text',
      yin: true
    }), new Extension('container', {
      argument: 'name',
      scope: {
        action: '0..n',
        anydata: '0..n',
        anyxml: '0..n',
        choice: '0..n',
        config: '0..1',
        container: '0..n',
        description: '0..1',
        grouping: '0..n',
        'if-feature': '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        must: '0..n',
        notification: '0..n',
        presence: '0..1',
        reference: '0..1',
        status: '0..1',
        typedef: '0..n',
        uses: '0..n',
        when: '0..1'
      },
      predicate: function(data) {
        if (data == null) {
          data = {};
        }
        return assert(data instanceof Object, "data must contain instance of Object");
      },
      construct: function(data, ctx) {
        if (data == null) {
          data = {};
        }
        if (ctx == null) {
          ctx = {};
        }
        return (new Model.Property(this.datakey, this)).join(data, ctx.state);
      },
      compose: function(data, opts) {
        var expr, i, k, kind, len, match, matches, parents, possibilities, ref1, ref2, v;
        if (opts == null) {
          opts = {};
        }
        if (!(data === Object(data) && !Array.isArray(data))) {
          return;
        }
        possibilities = (function() {
          var ref1, results;
          ref1 = this.scope;
          results = [];
          for (kind in ref1) {
            if (!hasProp.call(ref1, kind)) continue;
            results.push(this.lookup('extension', kind));
          }
          return results;
        }).call(this);
        matches = [];
        parents = (ref1 = opts.parents) != null ? ref1 : [];
        parents.push(data);
        for (k in data) {
          if (!hasProp.call(data, k)) continue;
          try {
            v = data[k];
          } catch (error) {
            continue;
          }
          if (indexOf.call(parents, v) >= 0) {
            this.debug("found circular entry for '" + k + "'");
            matches.push(Yang("anydata " + k + ";"));
            continue;
          }
          for (i = 0, len = possibilities.length; i < len; i++) {
            expr = possibilities[i];
            if (!((expr != null ? expr.compose : void 0) != null)) {
              continue;
            }
            this.debug("checking '" + k + "' to see if " + expr.tag);
            match = expr.compose(v, {
              tag: k,
              parents: parents
            });
            if (match != null) {
              break;
            }
          }
          if (match == null) {
            return;
          }
          matches.push(match);
        }
        parents.pop();
        return (ref2 = new Yang(this.tag, opts.tag, this))["extends"].apply(ref2, matches);
      }
    }), new Extension('default', {
      argument: 'value',
      transform: function(data) {
        return data != null ? data : this.tag;
      }
    }), new Extension('description', {
      argument: 'text',
      yin: true
    }), new Extension('deviate', {
      argument: 'value',
      scope: {
        config: '0..1',
        "default": '0..1',
        mandatory: '0..1',
        'max-elements': '0..1',
        'min-elements': '0..1',
        must: '0..n',
        type: '0..1',
        unique: '0..1',
        units: '0..1'
      }
    }), new Extension('deviation', {
      argument: 'target-node',
      scope: {
        description: '0..1',
        deviate: '1..n',
        reference: '0..1'
      }
    }), new Extension('enum', {
      argument: 'name',
      scope: {
        description: '0..1',
        'if-feature': '0..n',
        reference: '0..1',
        status: '0..1',
        value: '0..1'
      },
      resolve: function() {
        var base, cval;
        if ((base = this.parent).enumValue == null) {
          base.enumValue = 0;
        }
        if (this.value == null) {
          return this["extends"](this.constructor.parse("value " + (this.parent.enumValue++) + ";"));
        } else {
          cval = (Number(this.value.tag)) + 1;
          if (!(this.parent.enumValue > cval)) {
            return this.parent.enumValue = cval;
          }
        }
      }
    }), new Extension('error-app-tag', {
      argument: 'value'
    }), new Extension('error-message', {
      argument: 'value',
      yin: true
    }), new Extension('extension', {
      argument: 'extension-name',
      scope: {
        argument: '0..1',
        description: '0..1',
        reference: '0..1',
        status: '0..1'
      },
      resolve: function() {
        if (this.kind !== 'extension') {
          if (this.argument === this.source.argument) {
            delete this.argument;
          }
        }
        return this.once('bind', (function(_this) {
          return function() {
            var name, opts, prefix, ref1;
            prefix = _this.lookup('prefix');
            name = prefix + ":" + _this.tag;
            _this.debug("registering new bound extension '" + name + "'");
            opts = _this.binding();
            if (opts.argument == null) {
              opts.argument = (ref1 = _this.argument) != null ? ref1.valueOf() : void 0;
            }
            _this.source = new Extension("" + name, opts);
            if (opts.global === true) {
              _this.constructor.scope[name] = '0..n';
            }
            return _this.constructor.use(_this.source);
          };
        })(this));
      }
    }), new Extension('feature', {
      argument: 'name',
      scope: {
        description: '0..1',
        'if-feature': '0..n',
        reference: '0..1',
        status: '0..1'
      },
      construct: function(data, ctx) {
        var expr, feature, i, len, ref1;
        feature = this.binding;
        ref1 = this.exprs;
        for (i = 0, len = ref1.length; i < len; i++) {
          expr = ref1[i];
          feature = expr["eval"](feature);
        }
        if (feature != null) {
          (new Model.Property(this.tag, this)).join(ctx.engine);
        }
        return data;
      }
    }), new Extension('fraction-digits', {
      argument: 'value'
    }), new Extension('grouping', {
      argument: 'name',
      scope: {
        action: '0..n',
        anydata: '0..n',
        anyxml: '0..n',
        choice: '0..n',
        container: '0..n',
        description: '0..1',
        grouping: '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        notification: '0..n',
        reference: '0..1',
        status: '0..1',
        typedef: '0..n',
        uses: '0..n'
      },
      transform: function(data) {
        return data;
      }
    }), new Extension('identity', {
      argument: 'name',
      scope: {
        base: '0..1',
        description: '0..1',
        reference: '0..1',
        status: '0..1'
      },
      resolve: function() {
        if (this.base != null) {
          return this.lookup('identity', this.base.tag);
        }
      }
    }), new Extension('if-feature', {
      argument: 'feature-name',
      transform: function(data) {
        var feature;
        feature = this.lookup('feature', this.tag);
        if ((feature != null ? feature.binding : void 0) != null) {
          return data;
        }
      }
    }), new Extension('import', {
      argument: 'module',
      scope: {
        prefix: '1',
        'revision-date': '0..1'
      },
      resolve: function() {
        var module, ref1, rev;
        module = this.lookup('module', this.tag);
        if (module == null) {
          throw this.error("unable to resolve '" + this.tag + "' module");
        }
        Object.defineProperty(this, 'module', {
          configurable: true,
          value: module
        });
        rev = (ref1 = this['revision-date']) != null ? ref1.tag : void 0;
        if ((rev != null) && ((this.module.match('revision', rev)) == null)) {
          throw this.error("requested " + rev + " not available in " + this.tag);
        }
      },
      transform: function(data) {
        if (!(this.module.tag in Model.Store)) {
          this.debug("IMPORT: absorbing data for '" + this.tag + "'");
          this.module["eval"](data);
        }
        this.module.nodes.forEach(function(x) {
          return delete data[x.datakey];
        });
        return data;
      }
    }), new Extension('include', {
      argument: 'module',
      scope: {
        'revision-date': '0..1'
      },
      resolve: function() {
        var i, len, m, ref1, x;
        m = this.lookup('submodule', this.tag);
        if (m == null) {
          throw this.error("unable to resolve '" + this.tag + "' submodule");
        }
        if (this.parent.tag !== m['belongs-to'].tag) {
          throw m.error("requested submodule '" + this.tag + "' not belongs-to '" + this.parent.tag + "'");
        }
        Object.defineProperty(m['belongs-to'], 'module', {
          configurable: true,
          value: this.parent
        });
        ref1 = m.compile().elements;
        for (i = 0, len = ref1.length; i < len; i++) {
          x = ref1[i];
          if (m.scope[x.kind] === '0..n' && x.kind !== 'revision') {
            this.parent.update(x);
          }
        }
        return m.parent = this;
      }
    }), new Extension('input', {
      scope: {
        anydata: '0..n',
        anyxml: '0..n',
        choice: '0..n',
        container: '0..n',
        grouping: '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        typedef: '0..n',
        uses: '0..n'
      },
      transform: function(data, ctx) {
        var expr, i, index, input, j, keys, l, len, len1, len2, name1, node, ref1, ref2, ref3, singular;
        if (typeof data !== 'object') {
          return;
        }
        input = data;
        keys = this.nodes.reduce((function(a, b) {
          var c, i, len, ref1, ref2;
          if (b.kind === 'choice' && ((ref1 = b["case"]) != null ? ref1.length : void 0) > 0) {
            ref2 = b["case"];
            for (i = 0, len = ref2.length; i < len; i++) {
              c = ref2[i];
              a.push.apply(a, c.nodes.map(function(x) {
                return x.tag;
              }));
            }
          } else {
            a.push(b.tag);
          }
          return a;
        }), []);
        if ((data.length != null) && keys.length) {
          this.debug("input transform with: " + keys);
          if (data.length === 1 && typeof data[0] === 'object' && Object.keys(data[0]).some(function(x) {
            return indexOf.call(keys, x) >= 0;
          })) {
            singular = true;
            input = data[0];
          } else {
            ref1 = this.nodes;
            for (index = i = 0, len = ref1.length; i < len; index = ++i) {
              node = ref1[index];
              if (input[name1 = node.tag] == null) {
                input[name1] = data[index];
              }
            }
          }
        }
        ref2 = this.exprs;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          expr = ref2[j];
          if (input != null) {
            input = expr["eval"](input, ctx);
          }
        }
        switch (false) {
          case !singular:
            data[0] = input;
            break;
          case !((data.length != null) && keys.length):
            ref3 = this.nodes;
            for (index = l = 0, len2 = ref3.length; l < len2; index = ++l) {
              node = ref3[index];
              data[index] = input[node.tag];
            }
        }
        return input;
      },
      construct: function(data) {
        if (data == null) {
          data = {};
        }
        return (new Model.Property(this.kind, this)).join(data);
      },
      compose: function(data, opts) {
        var ref1, res, str;
        if (opts == null) {
          opts = {};
        }
        if (!(data instanceof Function)) {
          return;
        }
        str = data.toString().replace(STRIP_COMMENTS, '');
        res = (ref1 = str.slice(str.indexOf('(') + 1, str.indexOf(')')).match(ARGUMENT_NAMES)) != null ? ref1 : [];
        if (data.length !== res.length) {
          this.debug("argument length mismatch: expected " + data.length + " but got " + res.length);
        }
        return (new Yang(this.tag, null, this))["extends"](res.map(function(x) {
          return Yang("anydata " + x + ";");
        }));
      }
    }), new Extension('key', {
      argument: 'value',
      resolve: function() {
        return this.parent.once('compile:after', (function(_this) {
          return function() {
            _this.tag = _this.tag.split(' ');
            if (!(_this.tag.every(function(k) {
              return _this.parent.match('leaf', k) != null;
            }))) {
              throw _this.error("unable to reference key items as leaf elements", _this.parent);
            }
          };
        })(this));
      },
      transform: function(data) {
        var exists;
        if (!(data instanceof Object)) {
          return data;
        }
        switch (false) {
          case !(data instanceof Array):
            exists = {};
            data.forEach((function(_this) {
              return function(item) {
                var key;
                if (!(item instanceof Object)) {
                  return;
                }
                key = item['@key'];
                if (!((key != null) && !!key)) {
                  _this.debug("no key?");
                  _this.debug(item);
                }
                if (exists[key]) {
                  throw _this.error("key conflict for " + key);
                }
                return exists[key] = true;
              };
            })(this));
            break;
          case !!data.hasOwnProperty('@key'):
            this.debug("defining a new @key property into list item");
            Object.defineProperty(data, '@key', {
              get: (function() {
                return (this.tag.map(function(k) {
                  return data[k];
                })).join('+');
              }).bind(this)
            });
        }
        return data;
      },
      predicate: function(data) {
        if (!(data instanceof Object)) {
          return;
        }
        if (data instanceof Array) {
          return;
        }
        return assert(this.tag.every(function(k) {
          return data.hasOwnProperty(k);
        }), "data must contain values for all key leafs");
      }
    }), new Extension('leaf', {
      argument: 'name',
      scope: {
        config: '0..1',
        "default": '0..1',
        description: '0..1',
        'if-feature': '0..n',
        mandatory: '0..1',
        must: '0..n',
        reference: '0..1',
        status: '0..1',
        type: '0..1',
        units: '0..1',
        when: '0..1'
      },
      resolve: function() {
        var ref1;
        if (((ref1 = this.mandatory) != null ? ref1.tag : void 0) === 'true' && (this["default"] != null)) {
          throw this.error("cannot define 'default' when 'mandatory' is true");
        }
      },
      predicate: function(data) {
        if (data instanceof Error) {
          return;
        }
        if (data instanceof Array) {
          return assert(data.length === 1 && data[0] === null, "data cannot be an Array");
        } else {
          return assert(!(data instanceof Object), "data cannot be an Object");
        }
      },
      transform: function(data, ctx) {
        var expr, i, len, ref1;
        ref1 = this.exprs;
        for (i = 0, len = ref1.length; i < len; i++) {
          expr = ref1[i];
          if (expr.kind !== 'type') {
            data = expr["eval"](data, ctx);
          }
        }
        this.debug("leaf had");
        this.debug(data);
        if (this.type != null) {
          data = this.type.apply(data, ctx);
        }
        this.debug("leaf has");
        this.debug(data);
        return data;
      },
      construct: function(data, ctx) {
        if (data == null) {
          data = {};
        }
        if (ctx == null) {
          ctx = {};
        }
        return (new Model.Property(this.datakey, this)).join(data, ctx.state);
      },
      compose: function(data, opts) {
        var ref1, type;
        if (opts == null) {
          opts = {};
        }
        if (data instanceof Array) {
          return;
        }
        if (data instanceof Object && Object.keys(data).length > 0) {
          return;
        }
        type = (ref1 = this.lookup('extension', 'type')) != null ? typeof ref1.compose === "function" ? ref1.compose(data) : void 0 : void 0;
        if (type == null) {
          return;
        }
        this.debug("detected '" + opts.tag + "' as " + (type != null ? type.tag : void 0));
        return (new Yang(this.tag, opts.tag, this))["extends"](type);
      }
    }), new Extension('leaf-list', {
      argument: 'name',
      scope: {
        config: '0..1',
        description: '0..1',
        'if-feature': '0..n',
        'max-elements': '0..1',
        'min-elements': '0..1',
        must: '0..n',
        'ordered-by': '0..1',
        reference: '0..1',
        status: '0..1',
        type: '0..1',
        units: '0..1',
        when: '0..1'
      },
      predicate: function(data) {
        if (data == null) {
          data = [];
        }
        return assert(data instanceof Array, "data must contain an Array");
      },
      transform: function(data, ctx) {
        var expr, i, j, key, l, len, len1, output, ref1, ref2, ref3, value;
        if (data == null) {
          data = [];
          ref1 = this.exprs;
          for (i = 0, len = ref1.length; i < len; i++) {
            expr = ref1[i];
            data = expr["eval"](data, ctx);
          }
          return void 0;
        }
        if (!(data instanceof Array)) {
          data = [data];
        }
        data = data.filter(Boolean);
        output = {};
        for (key = j = 0, ref2 = data.length; 0 <= ref2 ? j < ref2 : j > ref2; key = 0 <= ref2 ? ++j : --j) {
          output[data[key]] = data[key];
        }
        data = (function() {
          var results;
          results = [];
          for (key in output) {
            value = output[key];
            results.push(value);
          }
          return results;
        })();
        ref3 = this.exprs;
        for (l = 0, len1 = ref3.length; l < len1; l++) {
          expr = ref3[l];
          if (expr.kind !== 'type') {
            data = expr["eval"](data, ctx);
          }
        }
        if (this.type != null) {
          data = this.type.apply(data, ctx);
        }
        return data;
      },
      construct: function(data, ctx) {
        if (data == null) {
          data = {};
        }
        if (ctx == null) {
          ctx = {};
        }
        return (new Model.Property(this.datakey, this)).join(data, ctx.state);
      },
      compose: function(data, opts) {
        var i, item, len, res, type_, types;
        if (opts == null) {
          opts = {};
        }
        if (!(data instanceof Array)) {
          return;
        }
        type_ = this.lookup('extension', 'type');
        types = [];
        for (i = 0, len = data.length; i < len; i++) {
          item = data[i];
          res = typeof type_.compose === "function" ? type_.compose(item) : void 0;
          if (res == null) {
            return;
          }
          types.push(res);
        }
        return (new Yang(this.tag, opts.tag, this))["extends"](types[0]);
      }
    }), new Extension('length', {
      argument: 'value',
      scope: {
        description: '0..1',
        'error-app-tag': '0..1',
        'error-message': '0..1',
        reference: '0..1'
      }
    }), new Extension('list', {
      argument: 'name',
      scope: {
        action: '0..n',
        anydata: '0..n',
        anyxml: '0..n',
        choice: '0..n',
        config: '0..1',
        container: '0..n',
        description: '0..1',
        grouping: '0..n',
        'if-feature': '0..n',
        key: '0..1',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        'max-elements': '0..1',
        'min-elements': '0..1',
        must: '0..n',
        notification: '0..n',
        'ordered-by': '0..1',
        reference: '0..1',
        status: '0..1',
        typedef: '0..n',
        unique: '0..1',
        uses: '0..n',
        when: '0..1'
      },
      predicate: function(data) {
        if (data == null) {
          data = {};
        }
        return assert(data instanceof Object, "data must be an Object");
      },
      transform: function(data, ctx) {
        var attr, expr, i, j, l, len, len1, len2, len3, n, ref1, ref2, ref3, ref4;
        if (ctx == null) {
          ctx = {};
        }
        if (data == null) {
          data = [];
          ref1 = this.attrs;
          for (i = 0, len = ref1.length; i < len; i++) {
            expr = ref1[i];
            data = expr["eval"](data, ctx);
          }
          return void 0;
        }
        if (data instanceof Array) {
          data.forEach((function(_this) {
            return function(item, idx) {
              return (new Model.Property(idx, _this)).join(data, ctx.state);
            };
          })(this));
          ref2 = this.attrs;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            attr = ref2[j];
            data = attr["eval"](data, ctx);
          }
        } else {
          ref3 = this.nodes;
          for (l = 0, len2 = ref3.length; l < len2; l++) {
            expr = ref3[l];
            if (data != null) {
              data = expr["eval"](data, ctx);
            }
          }
          ref4 = this.attrs;
          for (n = 0, len3 = ref4.length; n < len3; n++) {
            expr = ref4[n];
            if (data != null) {
              data = expr["eval"](data, ctx);
            }
          }
        }
        return data;
      },
      construct: function(data, ctx) {
        if (data == null) {
          data = {};
        }
        if (ctx == null) {
          ctx = {};
        }
        return (new Model.Property(this.datakey, this)).join(data, ctx.state);
      },
      compose: function(data, opts) {
        var expr, i, k, kind, len, match, matches, parents, possibilities, ref1, ref2, v;
        if (opts == null) {
          opts = {};
        }
        if (!(data instanceof Array && data.length > 0)) {
          return;
        }
        if (!data.every(function(x) {
          return typeof x === 'object';
        })) {
          return;
        }
        data = data[0];
        possibilities = (function() {
          var ref1, results;
          ref1 = this.scope;
          results = [];
          for (kind in ref1) {
            if (!hasProp.call(ref1, kind)) continue;
            results.push(this.lookup('extension', kind));
          }
          return results;
        }).call(this);
        matches = [];
        parents = (ref1 = opts.parents) != null ? ref1 : [];
        parents.push(data);
        for (k in data) {
          if (!hasProp.call(data, k)) continue;
          v = data[k];
          if (indexOf.call(parents, v) >= 0) {
            this.debug("found circular entry for '" + k + "'");
            matches.push(Yang("anydata " + k + ";"));
            continue;
          }
          for (i = 0, len = possibilities.length; i < len; i++) {
            expr = possibilities[i];
            if (!(expr != null)) {
              continue;
            }
            match = typeof expr.compose === "function" ? expr.compose(v, {
              tag: k,
              parents: parents
            }) : void 0;
            if (match != null) {
              break;
            }
          }
          if (match == null) {
            return;
          }
          matches.push(match);
        }
        parents.pop();
        return (ref2 = new Yang(this.tag, opts.tag, this))["extends"].apply(ref2, matches);
      }
    }), new Extension('mandatory', {
      argument: 'value',
      resolve: function() {
        return this.tag = this.tag === true || this.tag === 'true';
      },
      predicate: function(data) {
        return assert(this.tag !== true || (data != null) || (this.parent.binding != null), "data must be defined");
      }
    }), new Extension('max-elements', {
      argument: 'value',
      resolve: function() {
        if (this.tag !== 'unbounded') {
          return this.tag = Number(this.tag);
        }
      },
      predicate: function(data) {
        return assert(this.tag === 'unbounded' || !(data instanceof Array) || data.length <= this.tag, "data must contain less than maximum entries");
      }
    }), new Extension('min-elements', {
      argument: 'value',
      resolve: function() {
        return this.tag = Number(this.tag);
      },
      predicate: function(data) {
        return assert(!(data instanceof Array) || data.length >= this.tag, "data must contain more than minimum entries");
      }
    }), new Extension('modifier', {
      argument: 'value',
      resolve: function() {
        return this.tag = this.tag === 'invert-match';
      }
    }), new Extension('module', {
      argument: 'name',
      scope: {
        anydata: '0..n',
        anyxml: '0..n',
        augment: '0..n',
        choice: '0..n',
        contact: '0..1',
        container: '0..n',
        description: '0..1',
        deviation: '0..n',
        extension: '0..n',
        feature: '0..n',
        grouping: '0..n',
        identity: '0..n',
        "import": '0..n',
        include: '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        namespace: '0..1',
        notification: '0..n',
        organization: '0..1',
        prefix: '0..1',
        reference: '0..1',
        revision: '0..n',
        rpc: '0..n',
        typedef: '0..n',
        uses: '0..n',
        'yang-version': '0..1'
      },
      resolve: function() {
        var ref1, ref2;
        if (((ref1 = this['yang-version']) != null ? ref1.tag : void 0) === '1.1') {
          if (!((this.namespace != null) && (this.prefix != null))) {
            throw this.error("must define 'namespace' and 'prefix' for YANG 1.1 compliance");
          }
        }
        if (((ref2 = this.extension) != null ? ref2.length : void 0) > 0) {
          return this.debug("found " + this.extension.length + " new extension(s)");
        }
      },
      construct: function(data) {
        if (data == null) {
          data = {};
        }
        return (new Model(this.tag, this)).set(data);
      }
    }), new Extension('must', {
      argument: 'condition',
      scope: {
        description: '0..1',
        'error-app-tag': '0..1',
        'error-message': '0..1',
        reference: '0..1'
      }
    }), new Extension('namespace', {
      argument: 'uri'
    }), new Extension('notification', {
      argument: 'event',
      scope: {
        anydata: '0..n',
        anyxml: '0..n',
        choice: '0..n',
        container: '0..n',
        description: '0..1',
        grouping: '0..n',
        'if-feature': '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        reference: '0..1',
        status: '0..1',
        typedef: '0..n',
        uses: '0..n'
      },
      transform: function(data) {
        return data;
      }
    }), new Extension('ordered-by', {
      argument: 'value'
    }), new Extension('organization', {
      argument: 'text',
      yin: true
    }), new Extension('output', {
      scope: {
        anydata: '0..n',
        anyxml: '0..n',
        choice: '0..n',
        container: '0..n',
        grouping: '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        typedef: '0..n',
        uses: '0..n'
      },
      transform: function(data, ctx) {
        var cxt, expr, i, len, ref1;
        if (data instanceof Promise) {
          return data;
        }
        cxt = ctx["with"]({
          force: true
        });
        ref1 = this.exprs;
        for (i = 0, len = ref1.length; i < len; i++) {
          expr = ref1[i];
          if (data != null) {
            data = expr["eval"](data, ctx);
          }
        }
        return data;
      },
      construct: function(data, ctx) {
        if (data == null) {
          data = {};
        }
        if (ctx == null) {
          ctx = {};
        }
        return (new Model.Property(this.kind, this)).join(data, ctx.state);
      }
    }), new Extension('path', {
      argument: 'value',
      resolve: function() {
        return this.tag = this.normalizePath(this.tag);
      }
    }), new Extension('pattern', {
      argument: 'value',
      scope: {
        description: '0..1',
        'error-app-tag': '0..1',
        'error-message': '0..1',
        modifier: '0..1',
        reference: '0..1'
      },
      resolve: function() {
        return this.tag = new RegExp(this.tag);
      }
    }), new Extension('position', {
      argument: 'value'
    }), new Extension('prefix', {
      argument: 'value',
      resolve: function() {}
    }), new Extension('presence', {
      argument: 'value'
    }), new Extension('range', {
      argument: 'value',
      scope: {
        description: '0..1',
        'error-app-tag': '0..1',
        'error-message': '0..1',
        reference: '0..1'
      }
    }), new Extension('reference', {
      argument: 'value'
    }), new Extension('refine', {
      argument: 'target-node',
      scope: {
        "default": '0..1',
        description: '0..1',
        reference: '0..1',
        config: '0..1',
        'if-feature': '0..n',
        mandatory: '0..1',
        presence: '0..1',
        must: '0..n',
        'min-elements': '0..1',
        'max-elements': '0..1',
        units: '0..1'
      },
      resolve: function() {
        var target;
        target = this.parent.state.grouping.locate(this.tag);
        if (target == null) {
          console.warn(this.error("unable to locate '" + this.tag + "'"));
          return;
        }
        this.debug("APPLY " + this + " to " + target);
        return this.exprs.forEach(function(expr) {
          var ref1;
          switch (false) {
            case !target.hasOwnProperty(expr.kind):
              if ((ref1 = expr.kind) === 'must' || ref1 === 'if-feature') {
                return target["extends"](expr);
              } else {
                return target[expr.kind] = expr;
              }
              break;
            default:
              return target["extends"](expr);
          }
        });
      }
    }), new Extension('require-instance', {
      argument: 'value',
      resolve: function() {
        return this.tag = this.tag === true || this.tag === 'true';
      }
    }), new Extension('revision', {
      argument: 'date',
      scope: {
        description: '0..1',
        reference: '0..1',
        status: '0..1'
      }
    }), new Extension('revision-date', {
      argument: 'date'
    }), new Extension('rpc', {
      argument: 'name',
      scope: {
        description: '0..1',
        grouping: '0..n',
        'if-feature': '0..n',
        input: '0..1',
        output: '0..1',
        reference: '0..1',
        status: '0..1',
        typedef: '0..n'
      },
      predicate: function(data) {
        if (data == null) {
          data = function() {};
        }
        return assert(data instanceof Function, "data must be a Funcion");
      },
      transform: function(data) {
        var attr, i, len, ref1, ref2;
        if (data == null) {
          data = (ref1 = this.binding) != null ? ref1 : function() {
            throw new Error("missing function binding for " + this.path);
          };
        }
        if (!(data instanceof Function)) {
          this.debug(data);
          throw this.error("expected a function but got a '" + (typeof data) + "'");
        }
        ref2 = this.attrs;
        for (i = 0, len = ref2.length; i < len; i++) {
          attr = ref2[i];
          data = attr["eval"](data);
        }
        return data;
      },
      construct: function(data) {
        if (data == null) {
          data = {};
        }
        return (new Model.Property(this.datakey, this)).join(data);
      }
    }), new Extension('status', {
      argument: 'value',
      resolve: function() {
        var ref1;
        return this.tag = (ref1 = this.tag) != null ? ref1 : 'current';
      }
    }), new Extension('submodule', {
      argument: 'name',
      scope: {
        anyxml: '0..n',
        augment: '0..n',
        'belongs-to': '0..1',
        choice: '0..n',
        contact: '0..1',
        container: '0..n',
        description: '0..1',
        deviation: '0..n',
        extension: '0..n',
        feature: '0..n',
        grouping: '0..n',
        identity: '0..n',
        "import": '0..n',
        include: '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        notification: '0..n',
        organization: '0..1',
        reference: '0..1',
        revision: '0..n',
        rpc: '0..n',
        typedef: '0..n',
        uses: '0..n',
        'yang-version': '0..1'
      }
    }), new Extension('type', {
      argument: 'name',
      scope: {
        base: '0..1',
        bit: '0..n',
        "enum": '0..n',
        'fraction-digits': '0..1',
        length: '0..1',
        path: '0..1',
        pattern: '0..n',
        range: '0..1',
        'require-instance': '0..1',
        type: '0..n'
      },
      resolve: function() {
        var convert, typedef;
        if ((this.type != null) && this.tag !== 'union') {
          throw this.error("cannot have additional type definitions unless 'union'");
        }
        typedef = this.lookup('typedef', this.tag);
        if (typedef == null) {
          this.debug(this.parent);
          throw this.error("unable to resolve typedef for " + this.tag);
        }
        if (typedef.type != null) {
          this.once('compile:after', (function(_this) {
            return function() {
              var expr, i, len, ref1, results;
              ref1 = typedef.type.exprs;
              results = [];
              for (i = 0, len = ref1.length; i < len; i++) {
                expr = ref1[i];
                try {
                  results.push(_this.merge(expr));
                } catch (error) {}
              }
              return results;
            };
          })(this));
          this.primitive = typedef.type.primitive;
        } else {
          this.primitive = this.tag;
        }
        convert = typedef.convert;
        if (convert == null) {
          convert = typedef.compile().convert;
          if (convert == null) {
            throw this.error("no convert found for " + typedef.tag);
          }
        }
        this.convert = convert.bind(this);
        if ((this.parent != null) && this.parent.kind !== 'type') {
          try {
            return this.parent["extends"](typedef["default"], typedef.units);
          } catch (error) {}
        }
      },
      transform: function(data, ctx) {
        var res;
        if (!(data !== void 0 && (data instanceof Array || !(data instanceof Object)))) {
          return data;
        }
        if (data instanceof Array) {
          res = data.map((function(_this) {
            return function(x) {
              return _this.convert(x, ctx);
            };
          })(this));
          if (ctx.state.suppress && res.some(function(x) {
            return x instanceof Error;
          })) {
            ctx.defer(data);
          }
        } else {
          res = this.convert(data, ctx);
          if (ctx.state.suppress && res instanceof Error) {
            ctx.defer(data);
          }
        }
        return res;
      },
      compose: function(data, opts) {
        var e, i, len, ref1, typedef, typedefs;
        if (opts == null) {
          opts = {};
        }
        if (data instanceof Function) {
          return;
        }
        typedefs = this.lookup('typedef');
        ref1 = typedefs.concat({
          tag: 'unknown'
        });
        for (i = 0, len = ref1.length; i < len; i++) {
          typedef = ref1[i];
          this.debug("checking if " + typedef.tag);
          try {
            if ((typedef.convert(data)) !== void 0) {
              break;
            }
          } catch (error) {
            e = error;
            this.debug(e.message);
          }
        }
        if (typedef.tag === 'unknown') {
          return;
        }
        return new Yang(this.tag, typedef.tag);
      }
    }), new Extension('typedef', {
      argument: 'name',
      scope: {
        "default": '0..1',
        description: '0..1',
        units: '0..1',
        type: '0..1',
        reference: '0..1',
        status: '0..1'
      },
      resolve: function() {
        var builtin;
        if (this.type != null) {
          this.convert = this.type.compile().convert;
          return;
        }
        builtin = this.lookup('typedef', this.tag);
        if (builtin == null) {
          throw this.error("unable to resolve '" + this.tag + "' built-in type");
        }
        return this.convert = builtin.convert;
      }
    }), new Extension('unique', {
      argument: 'tag',
      resolve: function() {
        this.tag = this.tag.split(' ');
        if (!(this.tag.every((function(_this) {
          return function(k) {
            return _this.parent.match('leaf', k) != null;
          };
        })(this)))) {
          throw this.error("referenced unique items do not have leaf elements");
        }
      },
      predicate: function(data) {
        var isUnique, seen;
        if (!(data instanceof Array)) {
          return;
        }
        seen = {};
        isUnique = data.every((function(_this) {
          return function(item) {
            var key;
            if (!_this.tag.every(function(k) {
              return item[k] != null;
            })) {
              return true;
            }
            key = _this.tag.reduce((function(a, b) {
              return a += item[b];
            }), '');
            if (seen[key]) {
              return false;
            }
            seen[key] = true;
            return true;
          };
        })(this));
        return assert(isUnique, "data must contain unique entries of " + this.tag);
      }
    }), new Extension('units', {
      argument: 'value'
    }), new Extension('uses', {
      argument: 'grouping-name',
      scope: {
        augment: '0..n',
        description: '0..1',
        'if-feature': '0..n',
        refine: '0..n',
        reference: '0..1',
        status: '0..1',
        when: '0..1'
      },
      resolve: function() {
        var grouping, ref;
        grouping = this.lookup('grouping', this.tag);
        if (grouping == null) {
          throw this.error("unable to resolve " + this.tag + " grouping definition");
        }
        if (this.when == null) {
          ref = this.state.grouping = grouping.clone().compile();
          this.debug("extending with " + ref.nodes.length + " elements");
          return this.parent["extends"](ref.nodes);
        } else {
          return this.parent.on('apply:after', (function(_this) {
            return function(data) {
              var expr, i, len, ref1, results;
              if (data != null) {
                ref1 = _this.exprs;
                results = [];
                for (i = 0, len = ref1.length; i < len; i++) {
                  expr = ref1[i];
                  results.push(data = expr.apply(data));
                }
                return results;
              }
            };
          })(this));
        }
      },
      transform: function(data) {
        return data;
      }
    }), new Extension('value', {
      argument: 'value'
    }), new Extension('when', {
      argument: 'condition',
      scope: {
        description: '0..1',
        reference: '0..1'
      }
    }), new Extension('yang-version', {
      argument: 'value'
    }), new Extension('yin-element', {
      argument: 'value'
    })
  ];

}).call(this);
